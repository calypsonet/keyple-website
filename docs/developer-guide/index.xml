<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer guides | Eclipse Keyple</title><link>https://keyple.org/docs/developer-guide/</link><atom:link href="https://keyple.org/docs/developer-guide/index.xml" rel="self" type="application/rss+xml"/><description>Developer guides</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Â© Eclipse Foundation, Inc. All Rights Reserved.</copyright><image><url>https://keyple.org/images/logo_hu673a59176cd62c570f44ed2728665b48_42188_300x300_fit_lanczos_2.png</url><title>Developer guides</title><link>https://keyple.org/docs/developer-guide/</link></image><item><title>Common concepts</title><link>https://keyple.org/docs/developer-guide/common-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/common-concepts/</guid><description>&lt;p>This page describes the core elements of &lt;strong>Keyple&lt;/strong>, i.e. the concepts and APIs of &lt;strong>Keyple Core&lt;/strong> that are used to build any application implementing &lt;strong>Keyple&lt;/strong>.&lt;/p>
&lt;p>It is essential for the future user of &lt;strong>Keyple&lt;/strong> to be familiar with what is said in this chapter because the other modules made available by the project are all dependent on &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;h3 id="reader">Reader&lt;/h3>
&lt;p>Keyple&amp;rsquo;s primary goal being to interact with smart cards (or smartphones) worn by individuals, it is logical to put the Reader at the top of &lt;strong>Keyple Core&lt;/strong>&amp;rsquo;s concepts.&lt;/p>
&lt;p>Indeed, it is through the reader interfaces that all interactions with the smart cards will take place, either directly via &lt;strong>Keyple Core&lt;/strong> or using an extension (such as &lt;strong>Keyple Calypso&lt;/strong>).&lt;/p>
&lt;p>These interfaces provide the means to&lt;/p>
&lt;ul>
&lt;li>identify the underlying physical reader,&lt;/li>
&lt;li>manage communication protocols,&lt;/li>
&lt;li>detect the presence and communicate with smart cards.&lt;/li>
&lt;/ul>
&lt;p>The reader concept also applies to the hardware interfaces used to communicate with security elements such as SAMs (Secure Access Modules), which are sometimes integrated into devices and the virtual interfaces represented by the remote implementations.&lt;/p>
&lt;p>[link to the detailed description of the reader related classes]&lt;/p>
&lt;h3 id="plugin">Plugin&lt;/h3>
&lt;p>In Keyple language a plugin is a service that allows the management of readers of a certain type. The plugin is responsible for informing the application about the availability of readers. The readers of the same plugin are usually hardware linked to the same physical interface.&lt;/p>
&lt;p>Depending on its profile, an application may use different types of plugins to communicate with the different elements it needs (card, SAM).&lt;/p>
&lt;p>The Plugin interface essentially allows to list and retrieve the available readers.&lt;/p>
&lt;p>[link to the detailed description of the plugin related classes]&lt;/p>
&lt;h3 id="smart-card-service">Smart card service&lt;/h3>
&lt;p>This is the &lt;strong>Keyple Core&lt;/strong> service that concentrates the knowledge of active plugins and readers.&lt;/p>
&lt;p>At startup, a Keyple application must register the plugins it uses. Conversely, it can also unregister them.&lt;/p>
&lt;p>The &lt;strong>SmartCardService&lt;/strong> will then make sure that the resources used are properly released.&lt;/p>
&lt;p>[link to the detailed description of the reader related classes]&lt;/p>
&lt;h3 id="observation">Observation&lt;/h3>
&lt;p>The observation concept applies to readers as well as to plugins; optional, it is used depending on the needs.&lt;/p>
&lt;p>It consists in monitoring changes such as reader connection/disconnection or card insertion/removal and informing the observing application through a dedicated interface.&lt;/p>
&lt;p>Not all plugins and readers are observable.&lt;/p>
&lt;h3 id="selection">Selection&lt;/h3>
&lt;p>In Keyple the concept of selection is derived from the application selection defined by the ISO7816-4 standard.&lt;/p>
&lt;p>It supplements it by managing cards that do not have the standard command using identification mechanisms based on Answer To Reset and the communication protocol, and also by allowing the execution of commands immediately following application selection or detection.&lt;/p>
&lt;p>This principle optimizes the processing by allowing the application to elaborate advanced card discovery requests.&lt;/p>
&lt;p>Several targets can be defined by the application according to the different customer cards expected.&lt;/p>
&lt;p>The &lt;strong>default selection&lt;/strong> principle consists in providing an observable reader with a set of selection cases corresponding to the expected cards and receiving notifications containing not only the card identification but also the result of all additional commands that the application will have attached.&lt;/p>
&lt;h3 id="abstract-smart-card">Abstract smart card&lt;/h3>
&lt;p>The &lt;strong>abstract smart card&lt;/strong> concept is used by specific extensions (e.g. &lt;strong>Keyple Calypso&lt;/strong>) and by the &lt;strong>Keyple Core&lt;/strong> selection mechanism. It corresponds to an abstract container model implemented by the extension specific to a card type and returned by the selection process.&lt;/p>
&lt;p>This container will be able to carry all the useful information known about the card.&lt;/p>
&lt;p>Note: this concept, mentioned here for understanding, should not appear to the application developer if he uses a card extension.&lt;/p></description></item><item><title>Standalone application</title><link>https://keyple.org/docs/developer-guide/standalone-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/standalone-application/</guid><description>&lt;hr>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A standalone application is an application that runs in a device in contact
with the end user.&lt;/p>
&lt;p>It has at least one local smart card reader and manages itself the
interaction with the user.&lt;/p>
&lt;p>In the ticketing industry, it is typically the software that runs a
validator, a vending machine or a control terminal.&lt;/p>
&lt;p>The diagram below illustrates the organization of the local standalone
components:
&lt;figure >
&lt;a data-fancybox="" href="../../media/local-app/component/Local_Application_Components_Overview.svg" >
&lt;img src="../../media/local-app/component/Local_Application_Components_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read the
&lt;a href="../../docs/developer-guide/common-concepts/">common concepts&lt;/a> page and become familiar with the basic
concepts on which &lt;strong>Keyple&lt;/strong> is based.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the
implementation of &lt;strong>Keyple Core&lt;/strong>, please study the
&lt;a href="#workflow">workflow&lt;/a> proposed in the following chapter.&lt;/li>
&lt;li>Explore the
&lt;a href="#keyplecoreapi">Keyple Core API&lt;/a> to discover all the
possibilities offered by &lt;strong>Keyple Core&lt;/strong>.&lt;/li>
&lt;li>Take inspiration from the
&lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the
&lt;a href="../../docs/build-your-first-app/">Build your first app&lt;/a> section to configure your
environment.&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/">Java components&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/">C++ components&lt;/a> pages, import
&lt;strong>Keyple Core&lt;/strong> into your project and start playing with &lt;strong>Keyple&lt;/strong>.&lt;/li>
&lt;li>Don&amp;rsquo;t forget to explore the potential of Keyple card-specific
extensions such as &lt;strong>Keyple Calypso&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;h2 id="workflow">Workflow&lt;/h2>
&lt;p>&lt;strong>Keyple Core&lt;/strong> is built around the concepts described
&lt;a href="../../docs/developer-guide/common-concepts/">here&lt;/a> and sometimes proposes several ways to perform
an action or to achieve a result depending on the needs of the
application.&lt;/p>
&lt;p>The purpose of this section is to guide you in its use.&lt;/p>
&lt;h3 id="creation-of-the-smart-card-service">Creation of the Smart Card Service&lt;/h3>
&lt;p>This is the very first step in the realization of a Keyple application:&lt;/p>
&lt;pre>&lt;code class="language-java">/* Get the instance of the SmartCardService */
SmartCardService smartCardService = SmartCardService.getInstance();
&lt;/code>&lt;/pre>
&lt;p>The Smart Card Service is based on the SmartCardService object, which is
a singleton that must be held by the application all along its
execution.&lt;/p>
&lt;p>Its main role is to centralize Keyple resources and manage their
lifecycle.&lt;/p>
&lt;h3 id="choose-the-plugin">Choose the plugin&lt;/h3>
&lt;p>The Keyple application developer will choose the plugins he needs
according to the equipment on which his Keyple application will run.&lt;/p>
&lt;p>For example, if the environment is PC based, one will probably, but
without obligation, go for the PC/SC plugin.&lt;/p>
&lt;p>For an Andoid terminal environment, the plugin could be the standard
Android NFC plugin or one of the plugins available from the industrial
partners of the project. For a complete list of available plugins,
please see the
&lt;a href="https://keyple.org/components-java/">Java&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/">C++&lt;/a> pages.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
A new plugin can also be &lt;a href="../../docs/developer-guide/create-plugin/">created&lt;/a> if the envisaged hardware does not yet have its
plugin.
&lt;/div>
&lt;/div>
&lt;h3 id="register-the-plugin">Register the plugin&lt;/h3>
&lt;p>All Keyple plugins implement the &lt;code>Plugin&lt;/code> interface.&lt;/p>
&lt;p>The plugin registration consists in submitting its factory to the Smart
Card Service.&lt;/p>
&lt;pre>&lt;code class="language-java">/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(null, readerExceptionHandlerImpl));
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
&lt;p>The plugin factories all implement the interface expected by
SmartCardService.&lt;/p>
&lt;p>Depending on the case, the constructor of the factory provided by the
plugin can take parameters as argument.&lt;/p>
&lt;p>For example, in the code above, the PC/SC plugin expects exception
handlers, but in other cases it could be other parameters.&lt;/p>
&lt;/div>
&lt;/div>
&lt;h3 id="observation-of-the-plugin">Observation of the plugin&lt;/h3>
&lt;div class="alert alert-warning">
&lt;div>
The notion of plugin observation applies only to
hardware environments in which the readers are removable.
&lt;/div>
&lt;/div>
&lt;p>The observation of reader connections and disconnections is achieved
through a background task managed by &lt;strong>Keyple Core&lt;/strong>.&lt;/p>
&lt;p>It is therefore imperative to provide an exception handler to allow
&lt;strong>Keyple Core&lt;/strong> to warn the application in case of an execution error
during monitoring or event notification.&lt;/p>
&lt;p>Here is an example of exception handler implementation in a PC/SC plugin
context:&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class PluginExceptionHandlerImpl implements PluginObservationExceptionHandler {
@Override
public void onPluginObservationError(String pluginName, Throwable throwable) {
logger.error(&amp;quot;An unexpected plugin error occurred: {}&amp;quot;, pluginName, throwable);
}
}
}
/* Create an exception handler for plugin observation */
PluginExceptionHandlerImpl pluginExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, null));
...
&lt;/code>&lt;/pre>
&lt;p>For the observation of the plugin itself, the application must provide
an object implementing the &lt;code>PluginObserver&lt;/code> interface to the plugin
after having casted it in &lt;code>ObservablePlugin&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservablePlugin) plugin).addObserver(new PluginObserver());
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PluginObserver&lt;/code> interface requires the implementation of the
&lt;code>update&lt;/code> method that will be called by Keyple Core when notifying
plugin events.&lt;/p>
&lt;pre>&lt;code class="language-java">class PluginObserver implements ObservablePlugin.PluginObserver {
@Override
public void update(PluginEvent event) {
switch (event.getEventType()) {
case READER_CONNECTED:
// here the processing to be done when a reader is connected
...
break;
case READER_DISCONNECTED:
// here the processing to be done when a reader is disconnected
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;h3 id="retrieve-the-reader">Retrieve the reader&lt;/h3>
&lt;p>Readers are objects implementing the &lt;code>Reader&lt;/code> interface and are
returned by the plugin&amp;rsquo;s &lt;code>getReader&lt;/code> method taking the name of the
reader as argument.&lt;/p>
&lt;p>The names of the readers available from the plugin are returned as a
list of strings by the &lt;code>getReaderNames&lt;/code> method.&lt;/p>
&lt;p>The &lt;code>getReaders&lt;/code> method also allows to retrieve all readers in a Map
whose key is the name of the reader and the value the &lt;code>Reader&lt;/code>
object.&lt;/p>
&lt;p>Here is an example to get the 1st PC/SC reader:&lt;/p>
&lt;pre>&lt;code class="language-java">String readerName = plugin.getReaderNames().get(0);
Reader reader = plugin.getReader(readerName);
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Depending on the type of plugin, the reader names are
more or less dynamic (e.g. a PC/SC based system vs. an embedded
terminal), it is sometimes necessary to implement an identification
mechanism in order to assign the right reader to the right place in the
system (for example by using regular expressions).
&lt;/div>
&lt;/div>
&lt;h3 id="customize-the-reader-settings">Customize the reader settings&lt;/h3>
&lt;p>Take a close look at the parameters proposed by the plugin and its
readers.&lt;/p>
&lt;p>In particular, it is necessary to configure the expected communication
protocols, but it is also possible that other settings exist depending
on the hardware context.&lt;/p>
&lt;h3 id="observation-of-the-reader">Observation of the reader&lt;/h3>
&lt;p>The observation of inserting and removing cards from readers is similar
to the observation of plugins in that it requires the same operations,
i.e. the use of an exception handler and an object implementing a
dedicated interface.&lt;/p>
&lt;pre>&lt;code class="language-java">...
private static class ReaderExceptionHandlerImpl implements ReaderObservationExceptionHandler {
@Override
public void onReaderObservationError(String pluginName, String readerName, Throwable throwable) {
logger.error(&amp;quot;An unexpected reader error occurred: {}:{}&amp;quot;, pluginName, readerName, throwable);
}
}
}
/* Create an exception handler for reader observation */
ReaderExceptionHandlerImpl readerExceptionHandlerImpl = new ExceptionHandlerImpl();
/* Assign the PcscPlugin to the SmartCardService */
plugin = smartCardService.registerPlugin(new PcscPluginFactory(pluginExceptionHandlerImpl, readerExceptionHandlerImpl));
...
&lt;/code>&lt;/pre>
&lt;p>The observation of the events of the reader is done in a similar way to
that of the plugin, by adding an observer:&lt;/p>
&lt;pre>&lt;code class="language-java">((ObservableReader) reader).addObserver(new ReaderObserver());
&lt;/code>&lt;/pre>
&lt;p>and implementing the ReaderObserver interface:&lt;/p>
&lt;pre>&lt;code class="language-java">class ReaderObserver implements ObservableReader.ReaderObserver {
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_INSERTED:
// here the processing to be done when a card is inserted
...
break;
case CARD_MATCHED:
// here the processing to be done when a card matched the selection
...
break;
case CARD_REMOVED:
// here the processing to be done when a card is removed
...
break;
default:
break;
}
}
}
}
&lt;/code>&lt;/pre>
&lt;div class="alert alert-note">
&lt;div>
Observation of the readers is optional in Keyple. It
facilitates an event-driven programming mode, but an application
developer can choose not to observe a reader, either because this reader
is not designed to manage card insertions/withdrawals (for example an
Android OMAPI reader or a SAM reader), or because the application is
designed to directly manage the presence of a card (refer to the
&lt;code>Reader&lt;/code> interface).
&lt;/div>
&lt;/div>
&lt;h3 id="card-selection">Card selection&lt;/h3>
&lt;p>The card selection service offered by &lt;strong>Keyple Core&lt;/strong> gives multiple
possibilities to choose the processing according to the type of card
presented to the reader.&lt;/p>
&lt;p>It is based on a filtering process according to three possible criteria,
each of which is optional:&lt;/p>
&lt;ul>
&lt;li>the communication protocol of the card (usually also identifying a
card technology)&lt;/li>
&lt;li>the answer to reset of the card (ATR)&lt;/li>
&lt;li>the ISO standardized application identifier (AID)&lt;/li>
&lt;/ul>
&lt;p>Each of these criteria can be defined in a &lt;code>CardSelector&lt;/code> object.&lt;/p>
&lt;p>When a card is inserted, it is evaluated according to these criteria and
will be given the status &amp;ldquo;selected&amp;rdquo; or not.&lt;/p>
&lt;p>When a card is not selected, no other operation will be possible with
it. Depending on the chosen setting, the result of the selection will or
will not be made available to the application. It is thus possible to
directly ignore cards that do not correspond to the defined selection
criteria.&lt;/p>
&lt;p>When a card is selected, the result is an object that extends the
AbstractSmartCard and contains all the information known about the card
at that stage.&lt;/p>
&lt;p>In the case of a ISO standardized card, the application is selected with
the provided AID (additional settings are available to specify the
desired navigation within the card applications list).&lt;/p>
&lt;p>In addition to the selection process itself, specific APDU commands can
be sent to the card if the selection is successful. The output data of
these commands are available in the instance of the object
&lt;code>AbstractSmarCard&lt;/code>.&lt;/p>
&lt;p>The &lt;code>CardSelector&lt;/code> and the additional APDU commands are grouped in a
&lt;code>CardSelectionRequest&lt;/code> object.&lt;/p>
&lt;p>One or more &lt;code>CardSelectionRequest&lt;/code> can be set up to perform as many
selection cases, each targeting a particular card or application.&lt;/p>
&lt;p>The final selection process takes as input a list of
&lt;code>CardSelectionRequest&lt;/code> and gets in return a list of
&lt;code>CardSelectionResponse&lt;/code>.&lt;/p>
&lt;h4 id="card-selection-steps">Card selection steps&lt;/h4>
&lt;p>In this guide we will not show the addition of supplementary APDU
commands. Please refer to the Calypso guide for an implementation
example.&lt;/p>
&lt;h5 id="create-the-card-selection-service">Create the card selection service&lt;/h5>
&lt;p>The card selection service will be used all along the card search
process.&lt;/p>
&lt;pre>&lt;code class="language-java"> cardSelectionService = new CardSelectionsService();
&lt;/code>&lt;/pre>
&lt;h5 id="create-the-selection-cases">Create the selection cases&lt;/h5>
&lt;p>The application can create as many selection cases as the type of cards
expected. The order in which the selection cases are prepared is
important because it will favor the latency delay for the processing of
the cards corresponding to the first case. It is therefore recommended
to place the most common card profile in the application context first.&lt;/p>
&lt;pre>&lt;code class="language-java">/** Create a new class extending AbstractCardSelection */
public final class GenericCardSelection extends AbstractCardSelection {
public GenericCardSelection(CardSelector cardSelector) {
super(cardSelector);
}
@Override
protected AbstractSmartCard parse(CardSelectionResponse cardSelectionResponse) {
class GenericSmartCard extends AbstractSmartCard {
public GenericSmartCard(CardSelectionResponse cardSelectionResponse) {
super(cardSelectionResponse);
}
public String toJson() {
return &amp;quot;{}&amp;quot;;
}
}
return new GenericSmartCard(cardSelectionResponse);
}
}
final String aid1 = &amp;quot;AABBCCDDEE&amp;quot;;
final String aid2 = &amp;quot;EEDDCCBBAA&amp;quot;;
// first selection case targeting cards with AID1
GenericCardSelection cardSelector1 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid1).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector1);
// first selection case targeting cards with AID1
GenericCardSelection cardSelector2 =
new GenericCardSelection(
CardSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(CardSelector.AidSelector.builder().aidToSelect(aid2).build())
.build());
// Add the selection case to the current selection
cardSelectionsService.prepareSelection(cardSelector2);
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-a-non-observable-reader">Proceed to the selection with a non-observable reader&lt;/h5>
&lt;p>The &lt;code>processExplicitSelections&lt;/code> method of &lt;code>CardSelectionService&lt;/code>
performs the actual communication with the card.&lt;/p>
&lt;pre>&lt;code class="language-java">...
// Check if a card is present in the reader
if (!reader.isCardPresent()) {
logger.error(&amp;quot;No Po Card is present in the reader.&amp;quot;);
return;
}
// Actual card communication: operate through a single request the card selection
CardSelectionsResult cardSelectionsResult =
cardSelectionsService.processExplicitSelections(reader);
...
&lt;/code>&lt;/pre>
&lt;h5 id="proceed-to-the-selection-with-an-observable-reader">Proceed to the selection with an observable reader&lt;/h5>
&lt;p>In the case of an observable reader, the selection request is provided
to the reader (it is then named Default Selection) and will be processed
automatically as soon as a card is presented. The application is then
notified of the event with the data resulting from the selection.
Depending on the selection settings, the application will be notified of
all card presentations (&lt;code>CARD_INSERTED&lt;/code> event) or only those
presentations that led to a successful selection (&lt;code>CARD_MATCHED&lt;/code>
event).&lt;/p>
&lt;h6 id="add-a-default-selection">Add a default selection&lt;/h6>
&lt;pre>&lt;code class="language-java">// Provide the Reader with the selection operation to be processed when a card is inserted.
((ObservableReader) reader)
.setDefaultSelectionRequest(
cardSelectionService.getDefaultSelection().getDefaultSelectionsRequest(),
ObservableReader.NotificationMode.MATCHED_ONLY,
ObservableReader.PollingMode.REPEATING);
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>NotificationMode&lt;/code> allows you to specify whether all card
insertions should be reported to the application or only those that led
to a successful selection.&lt;/p>
&lt;p>&lt;code>PollingMode&lt;/code> indicates whether to go back to waiting for the card
after processing (&lt;code>REPEATING&lt;/code>) or let the application decide when to
restart the search (&lt;code>SINGLESHOT&lt;/code>) with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;p>Note: when the default selection is set with the &lt;code>PollingMode&lt;/code>
parameter, the card detection is started automatically. However, it is
possible to set a default selection without automatic start and by
starting the detection independently with &lt;code>startCardDetection&lt;/code>.&lt;/p>
&lt;h6 id="receive-the-result-as-an-event">Receive the result as an event&lt;/h6>
&lt;pre>&lt;code class="language-java">...
@Override
public void update(ReaderEvent event) {
switch (event.getEventType()) {
case CARD_MATCHED:
AbstractSmartCard selectedCard = null;
try {
selectedCard =
getDefaultSelection()
.processDefaultSelectionsResponse(event.getDefaultSelectionsResponse())
.getActiveSmartCard();
} catch (KeypleException e) {
logger.error(&amp;quot;Exception: {}&amp;quot;, e.getMessage());
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
if (selectedCard != null) {
logger.info(&amp;quot;Observer notification: the selection of the card has succeeded.&amp;quot;);
// insert the processing of the card here
...
logger.info(&amp;quot;= #### End of the card processing.&amp;quot;);
} else {
logger.error(
&amp;quot;The selection of the card has failed. Should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
}
break;
case CARD_INSERTED:
logger.error(
&amp;quot;CARD_INSERTED event: should not have occurred due to the MATCHED_ONLY selection mode.&amp;quot;);
break;
case CARD_REMOVED:
logger.trace(&amp;quot;There is no PO inserted anymore. Return to the waiting state...&amp;quot;);
break;
default:
break;
}
if (event.getEventType() == ReaderEvent.EventType.CARD_INSERTED
|| event.getEventType() == ReaderEvent.EventType.CARD_MATCHED) {
// Informs the underlying layer of the end of the card processing, in order to manage the
// removal sequence.
((ObservableReader) (event.getReader())).finalizeCardProcessing();
}
}
...
&lt;/code>&lt;/pre>
&lt;h5 id="get-the-selection-result">Get the selection result&lt;/h5>
&lt;p>The result of the selection is available in the &lt;code>AbstractSmartCard&lt;/code>
object.&lt;/p>
&lt;pre>&lt;code class="language-java">...
if (!cardSelectionsResult.hasActiveSelection()) {
logger.warn(&amp;quot;The selection of the application &amp;quot; + cardAid + &amp;quot; failed.&amp;quot;);
}
AbstractSmartCard smartCard = cardSelectionsResult.getActiveSmartCard();
logger.info(&amp;quot;The selection of the card has succeeded.&amp;quot;);
if (smartCard.hasFci()) {
String fci = ByteArrayUtil.toHex(smartCard.getFciBytes());
logger.info(&amp;quot;Application FCI = {}&amp;quot;, fci);
}
if (smartCard.hasAtr()) {
String atr = ByteArrayUtil.toHex(smartCard.getAtrBytes());
logger.info(&amp;quot;Card ATR = {}&amp;quot;, atr);
}
...
&lt;/code>&lt;/pre>
&lt;h3 id="implementation-of-the-application-service">Implementation of the application service&lt;/h3>
&lt;p>The applicative processing of the card that follows the selection of the
card is to be inserted in the processing of the &lt;code>CARD_INSERTED&lt;/code> or
&lt;code>CARD_MATCHED&lt;/code> event.&lt;/p>
&lt;p>It can be processed in the thread provided by the monitoring task or
detached in a separate thread. The application developer must pay
attention to the handling of exceptions in this part of the application.
Indeed, in case of a runtime exception, the information will be given to
the application via the exception handler configured beforehand.&lt;/p>
&lt;h3 id="stopping-the-application">Stopping the application&lt;/h3>
&lt;p>The clean shutdown of a Keyple application requires the release of
resources and in particular the shutdown of the observation threads.&lt;/p>
&lt;p>This is done by unregistering the plugins in the following way:&lt;/p>
&lt;pre>&lt;code class="language-java">smartCardService.unregisterPlugin(plugin.getName());
&lt;/code>&lt;/pre>
&lt;h2 id="keyple-core-api">Keyple Core API&lt;/h2>
&lt;p>To learn all the details of the &lt;strong>Keyple Core&lt;/strong> API, please consult the
&lt;a href="../../docs/api-reference/">Javadoc documentation&lt;/a>.&lt;/p>
&lt;p>However, here are two diagrams showing the main features of Keyple Core:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the
&lt;strong>Smart Card Service&lt;/strong> with in particular the observation mechanisms.
&lt;figure >
&lt;a data-fancybox="" href="../../media/local-app/component/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" >
&lt;img src="../../media/local-app/component/KeypleCore_Reader_ClassDiag_PluginSettingAndReaderAccess_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The diagram below represents the main classes used for selection
operations.
&lt;figure >
&lt;a data-fancybox="" href="../../media/local-app/component/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" >
&lt;img src="../../media/local-app/component/KeypleCore_CardSelection_ClassDiag_SelectorAndSelection_1_0_0.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>To help in the implementation of the different facilities offered by
Keyple to process smart cards, a set of examples is present in the
project repository
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc" target="_blank" rel="noopener">
&lt;i class="fab fa-github pr-1 fa-fw">&lt;/i> examples&lt;/a>&lt;/p>
&lt;p>Nevertheless, you will find below a brief description of them:&lt;/p>
&lt;h3 id="explicit-selection">Explicit Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection without observing the
reader, based on testing the presence of the card by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/UseCase1_ExplicitSelectionAid" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="default-selection">Default Selection&lt;/h3>
&lt;p>Shows the use of Keyple to make a card selection with observation of the
reader. A default selection is prepared, the presentation of a card
triggers the notification of a reader event to the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/UseCase2_DefaultSelectionNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="sequential-multiple-selection">Sequential Multiple Selection&lt;/h3>
&lt;p>Executes successively several independent selection operations with the
use of the ISO &amp;lsquo;NEXT&amp;rsquo; navigation flag.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/UseCase3_SequentialMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;p>Illustrates the case of a card exploration avec maintient du canal
physique ouvert.&lt;/p>
&lt;h3 id="grouped-multiple-selection">Grouped Multiple Selection&lt;/h3>
&lt;p>Executes a multiple selection with logical channel closure between each
selection.&lt;/p>
&lt;p>Allows the exploration of the applications of a card in a single
operation but without selection at the end.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/UseCase4_GroupedMultiSelection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-card-protocol-detection">Demo Card Protocol Detection&lt;/h3>
&lt;p>Demonstrates the use of Keyple in a context where several card
technologies are likely to be processed by the application.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/Demo_CardProtocolDetection" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h3 id="demo-observable-reader-notification">Demo Observable Reader Notification&lt;/h3>
&lt;p>Demonstrates the use of Keyple to implement the observation of a plugin
and its readers. Readers are dynamically created and an observer is
assigned to them.&lt;/p>
&lt;p>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/pc/Demo_ObservableReaderNotification" target="_blank" rel="noopener">see the code&lt;/a>&lt;/p>
&lt;h2 id="download">Download&lt;/h2>
&lt;p>The artifact &lt;strong>Keyple Core&lt;/strong> and how to integrate it into your
application is available here:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://keyple.org/components-java/core/">Keyple Core Java component&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://keyple.org/components-cpp/core/">Keyple Core C++ component&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Distributed application</title><link>https://keyple.org/docs/developer-guide/distributed-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/distributed-application/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Keyple provides the &amp;ldquo;Keyple Distributed&amp;rdquo; solution which allows a terminal to communicate with a smart card reader available in another terminal&lt;/strong>.&lt;/p>
&lt;p>In this way, you can manage transactions within a distributed architecture.&lt;/p>
&lt;p>The diagram below shows the role of the &lt;strong>Keyple Distributed&lt;/strong> components in the software layers used in a distributed architecture :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/component/Distributed_Component_Overview.svg" >
&lt;img src="../../media/distributed-application/component/Distributed_Component_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h2 id="how-to-use-it-">How to use it ?&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, read page
&lt;a href="../../docs/developer-guide/standalone-application/">Standalone application&lt;/a> to understand the main concepts of Keyple in a standalone application.&lt;/li>
&lt;li>Read chapter
&lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/li>
&lt;li>Read the introduction of chapter
&lt;a href="#configuration-modes">Configuration modes&lt;/a> to be informed about the different features and APIs proposed by the solution.&lt;/li>
&lt;li>Using chapter
&lt;a href="#use-cases">Use cases&lt;/a>, find your use case. This will help you to determine exactly which library and API to use.&lt;/li>
&lt;li>Using chapter
&lt;a href="#download">Download&lt;/a>, import into your project the libraries specified by your use case.&lt;/li>
&lt;li>Using chapter
&lt;a href="#network-configuration">Network configuration&lt;/a>, implement the transport layer adapted to your network configuration.&lt;/li>
&lt;li>Implement your ticketing services as specified in the associated use case.&lt;/li>
&lt;/ol>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this developer guide :&lt;/p>
&lt;div id="concepts-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Concept&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Remote Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-remote&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal not having local access to the smart card reader and that wishes to control the reader remotely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-local&lt;/code>.&lt;br>It must be imported and used by the application installed on the terminal having local access to the smart card reader but wishes to delegate all or part of the ticketing processing to a remote application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Lib&lt;/strong>&lt;/td>
&lt;td>This is the library &lt;code>keyple-java-distributed-network&lt;/code>.&lt;br>This library is &lt;strong>implicitly&lt;/strong> imported by &lt;strong>Remote Lib&lt;/strong> and &lt;strong>Local Lib&lt;/strong> because it contains common network elements.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Lib&lt;/strong>, this is a Keyple plugin which provides only &lt;strong>Remote Readers&lt;/strong> to the application. It manages data exchanges with the &lt;strong>Local Service&lt;/strong>. This plugin must be registered to the smart card service like any Keyple plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Reader&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Remote Plugin&lt;/strong>, this is a Keyple reader which has some specificities :&lt;br>- each remote reader is connected to a local reader ;&lt;br>- any command sent by the application to a remote reader will be forwarded to the associated local reader ;&lt;br>- any event occurs on a local reader or plugin will be forwarded to the associated remote reader or plugin.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>Part of the &lt;strong>Local Lib&lt;/strong>, this service ensures data exchange between the &lt;strong>Remote Plugin&lt;/strong> and local plugins and readers. It must be initialized and started by the host application.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific factory class to initialize them.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each have a specific utility class to access them everywhere in the code.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Node&lt;/strong>&lt;/td>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> each are bind to a specific internal node which is responsible for the interfacing with the &lt;strong>Network Endpoint&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Network Endpoint&lt;/strong>&lt;/td>
&lt;td>At the user&amp;rsquo;s charge, this component ensures the network exchanges between the &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> nodes.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#concepts-table-1 table th:first-of-type {
width: 130px;
}
&lt;/style>
&lt;p>The diagram below illustrates the main functional concepts through a standard use case :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/component/Distributed_Component_Concepts_1.svg" >
&lt;img src="../../media/distributed-application/component/Distributed_Component_Concepts_1.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>The second diagram below illustrates an arbitrary more complex possible use case with several hardware readers connected to different terminals.&lt;/p>
&lt;p>These could be for example a ticketing reloading service, where the intelligence would be on the terminal with remote readers, with thin clients on A &amp;amp; B terminals communicating locally with the cards.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for card communication.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/component/Distributed_Component_Concepts_2.svg" >
&lt;img src="../../media/distributed-application/component/Distributed_Component_Concepts_2.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>Here is another example, but this time it illustrates several &lt;strong>Remote Plugin&lt;/strong> components connected to the same &lt;strong>Local Service&lt;/strong>.&lt;/p>
&lt;p>These could be for example ticketing terminals with transaction logic, which communicate locally with cards, but which do not have SAM, and which use a SAM server with hardware reader.&lt;/p>
&lt;p>In this use case, the &lt;strong>Keyple Distributed&lt;/strong> solution is use for SAM communication.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/component/Distributed_Component_Concepts_3.svg" >
&lt;img src="../../media/distributed-application/component/Distributed_Component_Concepts_3.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h2 id="configuration-modes">Configuration modes&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution provides &lt;strong>3&lt;/strong> different configuration modes, each one having a specific
&lt;a href="#apis">API&lt;/a> designed on a &lt;strong>Client-Server&lt;/strong> model :&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Configuration mode&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#reader-client-side">Reader Client Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#reader-server-side">Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a>&lt;/td>
&lt;td>Allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 190px;
}
&lt;/style>
&lt;p>Each mode provides a different &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components and their associated factories and utility classes.&lt;/p>
&lt;p>Each &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> has a default name, but it&amp;rsquo;s possible to specify a custom name during the initialization phase.&lt;/p>
&lt;p>In an application, it is thus possible to use simultaneously several configuration modes and as many instances of a configuration mode as you want, as long as the components are initialized with different names.&lt;/p>
&lt;h3 id="reader-client-side">Reader Client Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>server&lt;/strong> application to control a smart card reader available on a &lt;strong>client&lt;/strong> (e.g. PO reader).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClient&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>LocalServiceClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>RemotePluginServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory by providing the network and plugin observer implementation. Please note that &lt;strong>this plugin is observable only to trigger ticketing services&lt;/strong> on the server side, but does not allow observation on the local plugin (reader insertion, etc&amp;hellip;),&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>await for events of type &lt;code>PluginEvent.READER_CONNECTED&lt;/code>,&lt;/li>
&lt;li>when an event occurs, get the specified remote reader from the &lt;strong>Remote Plugin&lt;/strong>,&lt;/li>
&lt;li>use information inside the remote reader to identify the ticketing service to execute,&lt;/li>
&lt;li>execute the specified ticketing service using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service and get the local reader to connect to the server,&lt;/li>
&lt;li>execute the remote service using the &lt;strong>Local Service&lt;/strong> API by indicating the ticketing service id to execute and transmitting to the server if needed personal information or smart card content previously read.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="illustration">ILLUSTRATION&lt;/h4>
&lt;p>The following sequence diagram shows the capabilities of the plugin through an arbitrary example that illustrates :&lt;/p>
&lt;ul>
&lt;li>the initialization phase of the local and remote components ;&lt;/li>
&lt;li>the registration of the local plugin and observable reader ;&lt;/li>
&lt;li>the selection phase of an observable reader carried out directly by the client ;&lt;/li>
&lt;li>the sending of the selection result and additional information to the server to remotely perform a specific ticketing service (materialization, validation, etc&amp;hellip;) ;&lt;/li>
&lt;li>the reception by the server of the transmitted data ;&lt;/li>
&lt;li>the execution of the remote ticketing service ;&lt;/li>
&lt;li>the server subscription to observable reader events ;&lt;/li>
&lt;li>the sending of information to the client at the end of processing.&lt;/li>
&lt;/ul>
&lt;p>Note that the network layer is deliberately hide in this diagram. Its implementation is described in the
&lt;a href="#network-configuration">Network configuration&lt;/a> chapter.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/sequence/Distributed_Sequence_ReaderClientSide_API.svg" >
&lt;img src="../../media/distributed-application/sequence/Distributed_Sequence_ReaderClientSide_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="reader-server-side">Reader Server Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a smart card reader available on a &lt;strong>server&lt;/strong> (e.g. SAM reader).&lt;/p>
&lt;p>It also allows to observe the plugin events (such as reader connection, etc&amp;hellip;) if desired.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClient&lt;/code> or&lt;br>&lt;code>ObservableRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>RemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>LocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-1">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local plugin with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="operating-mode-2">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server side :
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client side :
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local observable plugin with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="pool-reader-server-side">Pool Reader Server Side&lt;/h3>
&lt;p>This configuration mode allows a &lt;strong>client&lt;/strong> application to control a &lt;strong>pool&lt;/strong> of smart cards readers available on a &lt;strong>server&lt;/strong> (e.g. HSM readers).&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>API&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Library&lt;/strong>&lt;/td>
&lt;td>Remote Lib&lt;/td>
&lt;td>Local Lib&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Remote Plugin&lt;/strong> / &lt;strong>Local Service&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClient&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Factory&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientFactory&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerFactory&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Utility&lt;/strong>&lt;/td>
&lt;td>&lt;code>PoolRemotePluginClientUtils&lt;/code>&lt;/td>
&lt;td>&lt;code>PoolLocalServiceServerUtils&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operating-mode-3">OPERATING MODE&lt;/h4>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>configure the factory and start the &lt;strong>Local Service&lt;/strong> by providing the network implementation,&lt;/li>
&lt;li>register at least a local pool plugin to the smart card service.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>configure the factory by providing the network implementation,&lt;/li>
&lt;li>register the &lt;strong>Remote Plugin&lt;/strong> to the smart card service using the factory,&lt;/li>
&lt;li>use the &lt;strong>Remote Plugin&lt;/strong> and its remote readers as a local pool plugin with local readers.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="use-cases">Use cases&lt;/h2>
&lt;p>Here is a summary table of all proposed use cases. Search for the one that corresponds to your need and then look at the associated description :&lt;/p>
&lt;div id="use-cases-table-2">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Use Case&lt;/th>
&lt;th style="text-align:center">Reader type&lt;/th>
&lt;th style="text-align:center">Reader endpoint&lt;/th>
&lt;th style="text-align:center">Reader observation&lt;/th>
&lt;th style="text-align:center">Plugin observation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-1">UC 1&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-2">UC 2&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Client&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-3">UC 3&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-4">UC 4&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-5">UC 5&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-6">UC 6&lt;/a>&lt;/td>
&lt;td style="text-align:center">Simple&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">
&lt;a href="#uc-7">UC 7&lt;/a>&lt;/td>
&lt;td style="text-align:center">Pool&lt;/td>
&lt;td style="text-align:center">Server&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#use-cases-table-2 table th:nth-of-type(6) {
width: 240px;
}
&lt;/style>
&lt;h4 id="uc-1">UC 1&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the client side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>RemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-2">UC 2&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-client-side">Reader Client Side&lt;/a> configuration mode.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withReaderObservation(...)&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableRemoteReaderServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>To observe &amp;ldquo;remotely&amp;rdquo; the reader events, you must :&lt;/p>
&lt;ul>
&lt;li>Server
&lt;ol>
&lt;li>register at least one observer to the remote reader created during the first client call and await for reader events,&lt;/li>
&lt;li>retrieve the remote reader from the &lt;strong>Remote Plugin&lt;/strong> &lt;strong>imperatively&lt;/strong> using the reader name contained in the received event,&lt;/li>
&lt;li>execute the ticketing service associated to the event using the remote reader and all of its others information,&lt;/li>
&lt;li>terminate the remote ticketing service associated to the event using the &lt;strong>Remote Plugin&lt;/strong> API by transmitting if needed personal information to the client.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Client
&lt;ol>
&lt;li>execute a remote service first in order to connect a remote reader to the local reader and to allow the remote application to subscribe to the events of the remote reader.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="uc-3">UC 3&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-4">UC 4&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>RemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withoutPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-5">UC 5&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you don&amp;rsquo;t plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that it is still possible to observe locally the reader on the server side if needed.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withoutReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code> or &lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-6">UC 6&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#reader-server-side">Reader Server Side&lt;/a> configuration mode with the &lt;code>ObservableRemotePluginClient&lt;/code> plugin.&lt;/p>
&lt;p>Use this mode if you plan to observe &amp;ldquo;remotely&amp;rdquo; the events related to the local reader (smart card insertion, removal, etc&amp;hellip;).&lt;/p>
&lt;p>Please note that this mode is only possible if the local reader is observable.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withPluginObservation()&lt;/code>&lt;br>&lt;code>withReaderObservation()&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;td>&lt;code>ObservableReader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="uc-7">UC 7&lt;/h4>
&lt;p>This use case requires to use the
&lt;a href="#pool-reader-server-side">Pool Reader Server Side&lt;/a> configuration mode.&lt;/p>
&lt;p>This unique mode proposed for this plugin does not allow to observe the local reader.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Possible readers to use&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;td>&lt;code>Reader&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="network-configuration">Network configuration&lt;/h2>
&lt;p>The &lt;strong>Keyple Distributed&lt;/strong> solution &lt;strong>does not provide&lt;/strong> the network layer implementation, but it provides a set of SPIs (Service Provider Interfaces) to be implemented by the user in order to enable it to exchange data between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components.&lt;/p>
&lt;h3 id="synchronous">Synchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Client-Server &lt;strong>Synchronous&lt;/strong> communication protocol, such as standard HTTP for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>SyncEndpointClient&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>SyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>SyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withSyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withSyncNode()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>-&lt;/td>
&lt;td>&lt;code>getSyncNode()&lt;/code> or&lt;br> &lt;code>getSyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement in a context with a &lt;strong>single server instance&lt;/strong> :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/sequence/Distributed_Sequence_SyncNode_API.svg" >
&lt;img src="../../media/distributed-application/sequence/Distributed_Sequence_SyncNode_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>In a context with several server instances, a mechanism must be implemented to ensure that all messages containing information about a &lt;code>serverNodeId&lt;/code> are routed to the server associated with a &lt;code>SyncNodeServer&lt;/code> node having the &lt;code>serverNodeId&lt;/code>.&lt;/p>
&lt;h3 id="asynchronous">Asynchronous&lt;/h3>
&lt;p>Choose this mode if you want to implement a Full-Duplex &lt;strong>Asynchronous&lt;/strong> communication protocol, such as Web Sockets for example.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Client&lt;/th>
&lt;th>Server&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SPI to be implemented&lt;/td>
&lt;td>&lt;code>AsyncEndpointClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncEndpointServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node API&lt;/td>
&lt;td>&lt;code>AsyncNodeClient&lt;/code>&lt;/td>
&lt;td>&lt;code>AsyncNodeServer&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Methods to be used when initializing the factory&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>withAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Utility method to use to access the node&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;td>&lt;code>getAsyncNode()&lt;/code> or&lt;br> &lt;code>getAsyncNode(...)&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Here is the minimal algorithm to implement :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/sequence/Distributed_Sequence_AsyncNode_API.svg" >
&lt;img src="../../media/distributed-application/sequence/Distributed_Sequence_AsyncNode_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="exchanged-data">Exchanged data&lt;/h3>
&lt;p>The data exchanged between &lt;strong>Remote Plugin&lt;/strong> and &lt;strong>Local Service&lt;/strong> components are contained in the DTO (Data Transfer Object) &lt;code>MessageDto&lt;/code>. It is built and processed by the plugin and &lt;strong>you don&amp;rsquo;t need to modify it&lt;/strong>.&lt;/p>
&lt;p>However, it is necessary in some contexts to access certain information such as the &lt;code>sessionId&lt;/code> in the case of asynchronous communication or the &lt;code>serverNodeId&lt;/code> in the case of synchronous communication with several server instances.&lt;/p>
&lt;h2 id="apis">APIs&lt;/h2>
&lt;p>The class diagrams below shows the different APIs exposed and SPIs required by the &lt;strong>Keyple Distributed&lt;/strong> solution.&lt;/p>
&lt;p>An &lt;strong>SPI&lt;/strong> (Service Provider Interface) is an interface that must be implemented by the user.&lt;/p>
&lt;p>Here are the available APIs depending on the library imported by your project :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th style="text-align:center">Remote Lib&lt;/th>
&lt;th style="text-align:center">Local Lib&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;a href="#network-api">Network API&lt;/a>&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#remote-api">Remote API&lt;/a>&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;a href="#local-api">Local API&lt;/a>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">âï¸&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The associated &lt;strong>API&lt;/strong> documentations are accessible from the page
&lt;a href="../../docs/api-reference/">API Reference&lt;/a>.&lt;/p>
&lt;h3 id="network-api">Network API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-network/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/class/Distributed_Class_Network_API.svg" >
&lt;img src="../../media/distributed-application/class/Distributed_Class_Network_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="remote-api">Remote API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-remote/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/class/Distributed_Class_Remote_API.svg" >
&lt;img src="../../media/distributed-application/class/Distributed_Class_Remote_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="local-api">Local API&lt;/h3>
&lt;p>The associated &lt;strong>API&lt;/strong> documentation is available &lt;a href="../../api-reference/java-api/keyple-java-distributed-local/1.0.0/index.html">here&lt;/a>.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/distributed-application/class/Distributed_Class_Local_API.svg" >
&lt;img src="../../media/distributed-application/class/Distributed_Class_Local_API.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/generic/distributed" target="_blank" rel="noopener">Java examples&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="download">Download&lt;/h2>
&lt;ul>
&lt;li>
&lt;a href="../../components-java/distributed-systems/">Java components&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Calypso application</title><link>https://keyple.org/docs/developer-guide/calypso-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/calypso-application/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>&lt;strong>Work in Progress&lt;/strong>&lt;/p>
&lt;p>Keyple API was designed to support an extension system. On top of &lt;strong>Keyple Core&lt;/strong>, APIs can be developed to extend
Keyple features. For example, Calypso Network Association provides &lt;strong>Keyple Calypso Extension&lt;/strong>.&lt;/p>
&lt;p>The use of &lt;strong>Keyple Calypso Extension&lt;/strong> open the ability to operate commands with a calypso Portable Object and to manage a
secure calypso transaction.&lt;/p>
&lt;p>The diagram below shows the role of the &lt;strong>Keyple Calypso Extension&lt;/strong> components in the software layers for a standalone application :&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/calypso-app-development/component/Local_Component_Overview.svg" >
&lt;img src="../../media/calypso-app-development/component/Local_Component_Overview.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h2 id="before-you-start">Before you start&lt;/h2>
&lt;ol>
&lt;li>In pre-requisite, have knowledge of the standard Calypso.&lt;/li>
&lt;li>Read the
&lt;a href="../../docs/developer-guide/common-concepts/">common concepts&lt;/a> page and become familiar with the basic concepts on which &lt;strong>Keyple&lt;/strong> is based.&lt;/li>
&lt;li>Any implementation of a Keyple application starts with the implementation of &lt;strong>Keyple Core&lt;/strong>, please study the
&lt;a href="../../docs/developer-guide/standalone-application/">workflow&lt;/a> proposed in Standalone application guide.&lt;/li>
&lt;li>Read chapter
&lt;a href="#concepts">Concepts&lt;/a> to understand the main terms and concepts of the &lt;strong>Keyple Calypso Extension&lt;/strong> API.&lt;/li>
&lt;li>Explore the
&lt;a href="#keyplecalypsoapi">Keyple Calypso API&lt;/a> to discover all the possibilities offered by &lt;strong>Keyple Calypso Extension&lt;/strong>.&lt;/li>
&lt;li>Take inspiration from the
&lt;a href="#examples">examples&lt;/a>.&lt;/li>
&lt;li>Follow the explanations given in the
&lt;a href="../../docs/build-your-first-app/">Build your first app&lt;/a> section to configure your environment.&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/core/">Java components&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/core/">C++ components&lt;/a> pages, import &lt;strong>Keyple Core&lt;/strong> into your project.&lt;/li>
&lt;li>Using the
&lt;a href="https://keyple.org/components-java/extensions/calypso/">Java components&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/extensions/calypso/">C++ components&lt;/a> pages, import &lt;strong>Keyple Calypso Extension&lt;/strong> into your project.&lt;/li>
&lt;li>Start playing with &lt;strong>Keyple&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;h2 id="concepts">Concepts&lt;/h2>
&lt;p>Here are the main concepts to keep in mind before continuing to read this developer guide :&lt;/p>
&lt;h3 id="calypso-po">Calypso PO&lt;/h3>
&lt;p>Concentrate all known informations about the Personal Object being processed. Accessible informations are&lt;/p>
&lt;ul>
&lt;li>The application identification fields (revision/version, class, DF name, serial number, ATR, issuer)&lt;/li>
&lt;li>The indication of the presence of optional features (Stored Value, PIN, Rev3.2 mode, ratification management)&lt;/li>
&lt;li>The management information of the modification buffer&lt;/li>
&lt;li>The invalidation status&lt;/li>
&lt;li>The files, counters, SV data read or modified during the execution of the processes defined by PoTransaction&lt;/li>
&lt;/ul>
&lt;p>Calypso PO fields are populated from a CardSelectionResponse obtained through the process of a PO selection.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
//Retrieve PO's informations
String atr = calypsoPo.getAtr()
byte[] applicationSerial+Number = calypsoPo.getApplicationSerialNumber()
//SFI_EventLog = 0x08
ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog);
//SFI_EnvironmentAndHolder = 0x07
ElementaryFile efEnvironmentAndHolder =calypsoPo.getFileBySfi(SFI_EnvironmentAndHolder);
...
&lt;/code>&lt;/pre>
&lt;h3 id="elementaryfile">ElementaryFile&lt;/h3>
&lt;p>Object containing the description of a Calypso Elementary File. Can be retrieved from Calypso PO using its SFI.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
ElementaryFile efEventLog = calypsoPo.getFileBySfi(SFI_EventLog);
//Read data content of sevent log elemenatary file
String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent());
...
&lt;/code>&lt;/pre>
&lt;h3 id="poselection">PoSelection&lt;/h3>
&lt;p>Service extending Keyple Core Abstract Card Selection to manage specific features of Calypso POs during the selection:&lt;/p>
&lt;ul>
&lt;li>Send APDU Commands to the POs right after the card selection.&lt;/li>
&lt;li>Produce a Calypso PO from the CardSelectionResponse. The object is filled with the PO identification data from the FCI and the
possible responses to additional APDU commands executed after the selection.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java"> ...
// Prepare a Calypso PO selection
CardSelectionsService cardSelectionsService = new CardSelectionsService();
// Setting of an AID based selection of a Calypso REV3 PO
// Select the first application matching the selection AID whatever the card communication
// protocol keep the logical channel open after the selection
// Calypso selection: configures a PoSelection with all the desired attributes to
// make the selection and read additional information afterwards
PoSelection poSelection =
new PoSelection(
PoSelector.builder()
.cardProtocol(ContactlessCardCommonProtocols.ISO_14443_4.name())
.aidSelector(
CardSelector.AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build())
.invalidatedPo(PoSelector.InvalidatedPo.REJECT)
.build());
// Prepare the reading order.
poSelection.prepareReadRecordFile(
CalypsoClassicInfo.SFI_EnvironmentAndHolder, CalypsoClassicInfo.RECORD_NUMBER_1);
// Add the selection case to the current selection (we could have added other cases
// here)
cardSelectionsService.prepareSelection(poSelection);
CalypsoPo calypsoPo = (CalypsoPo) cardSelectionsService.processExplicitSelections(poReader).getActiveSmartCard();
...
&lt;/code>&lt;/pre>
&lt;h3 id="calypso-sam">Calypso SAM&lt;/h3>
&lt;p>Concentrates all the informations we know about the SAM currently selected. Accessible informations are:&lt;/p>
&lt;ul>
&lt;li>The Sam Revision&lt;/li>
&lt;li>The Serial number&lt;/li>
&lt;li>The Platform identifier&lt;/li>
&lt;li>The Application Type&lt;/li>
&lt;li>The Application SubType&lt;/li>
&lt;li>The Software Issuer identifier&lt;/li>
&lt;li>The Software Version number&lt;/li>
&lt;li>The Software Revision number&lt;/li>
&lt;/ul>
&lt;p>Calypso SAM fields are populated by analysis of the ATR within a CardSelectionResponse obtained through the process of a SAM selection.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
byte[] serialNumber = calypsoSam.getSerialNumber()
...
&lt;/code>&lt;/pre>
&lt;h3 id="samselection">SamSelection&lt;/h3>
&lt;p>Service extending Keyple Core Abstract Card Selection specialized to manage the specific characteristics of Calypso SAMs.
The service provides an instance of Calypso SAM and may execute the unlock command during the selection process.&lt;/p>
&lt;pre>&lt;code class="language-java"> ...
CardSelectionsService samSelection = new CardSelectionsService();
//Sam selection parameters
SamSelector samSelector = SamSelector.builder().samRevision(SamRevision.C1).serialNumber(&amp;quot;.*&amp;quot;).build();
samSelection.prepareSelection(new SamSelection(samSelector));
//Sam reader retrieved from registered plugin
CardSelectionsResult cardSelectionsResult = samSelection.processExplicitSelections(samReader);
if (!cardSelectionsResult.hasActiveSelection()) {
throw new IllegalStateException(&amp;quot;Unable to open a logical channel for SAM!&amp;quot;);
}
//Cast selected card to CalypsoSam
CalypsoSam calypsoSam = (CalypsoSam) cardSelectionsResult.getActiveSmartCard();
...
&lt;/code>&lt;/pre>
&lt;h3 id="posecuritysettings">PoSecuritySettings&lt;/h3>
&lt;p>Concentrate the security settings involved in Calypso Secure Sessions:&lt;/p>
&lt;ul>
&lt;li>A reference to the Sam resource&lt;/li>
&lt;li>The default KIF&lt;/li>
&lt;li>The default KVC&lt;/li>
&lt;li>The default Key Record Number&lt;/li>
&lt;li>The modification mode&lt;/li>
&lt;li>The ratification mode&lt;/li>
&lt;li>The pin transmission mode&lt;/li>
&lt;li>The default Pin Ciphering Key&lt;/li>
&lt;li>The SV Get Log Reade mode&lt;/li>
&lt;li>the SV Negative balance&lt;/li>
&lt;/ul>
&lt;p>The fields are populated with default values when the object is instantiated but can be customized to adjust the settings
to the application needs.&lt;/p>
&lt;pre>&lt;code class="language-java"> // Security settings
// Both Reload and Debit SV logs are requested
PoSecuritySettings poSecuritySettings =
new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.svGetLogReadMode(SvSettings.LogRead.ALL)
.build();
&lt;/code>&lt;/pre>
&lt;h3 id="sam-resource-managers">SAM Resource Managers&lt;/h3>
&lt;p>Services providing methods to allocate/deallocate SAM resources. Keyple Calypso API provides 3 type of managers: Default,
Factory, Pool. The choice of the manager to use depends on the abilities of the plugin used for the SAM connexion.&lt;/p>
&lt;h3 id="potransaction">PoTransaction&lt;/h3>
&lt;p>Service providing high-level API to manage transactions with a Calypso PO. The tied Calypso PO Object is kept and updated at
each step of using this service.&lt;/p>
&lt;p>This service workflow is composed of two steps:&lt;/p>
&lt;ul>
&lt;li>Prepare the commands to be executed to the PO&lt;/li>
&lt;li>Process the prepared commands. Regarding of commands, the presence of SAM could be mandatory.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java"> ...
CardResource&amp;lt;CalypsoPo&amp;gt; poResource = new CardResource&amp;lt;CalypsoPo&amp;gt;(poReader, calypsoPo);
PoTransaction poTransaction = new PoTransaction(poResource, poSecuritySettings);
// Read the EventLog file at the Session Opening
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_EventLog, CalypsoClassicInfo.RECORD_NUMBER_1);
// Open a secure session (DEBIT level) and execute the prepared command
poTransaction.processOpening(PoTransaction.SessionSetting.AccessLevel.SESSION_LVL_DEBIT);
// Get and display the EventLog data
ElementaryFile efEventLog = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_EventLog);
String eventLog = ByteArrayUtil.toHex(efEventLog.getData().getContent());
// Prepare a SV Debit (this command could also have been placed before processOpening
// since it is not followed by any other command)
poTransaction.prepareSvGet(SvSettings.Operation.DEBIT, SvSettings.Action.DO);
// Execute the prepared command
poTransaction.processPoCommands();
//Get updated sv balance
int svBalance = calypsoPo.getSvBalance()
//Get the updated SV last transaction number
int svLastTNum = calypsoPo.getSvLastTNum()
...
&lt;/code>&lt;/pre>
&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the &lt;strong>Transaction package&lt;/strong>.
&lt;figure >
&lt;a data-fancybox="" href="../../media/calypso-app-development/class/TransactionPackage_Class.svg" >
&lt;img src="../../media/calypso-app-development/class/TransactionPackage_Class.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The diagram below represents the main classes implemented around the &lt;strong>Command package&lt;/strong>.
&lt;figure >
&lt;a data-fancybox="" href="../../media/calypso-app-development/class/CommandPackage_Class.svg" >
&lt;img src="../../media/calypso-app-development/class/CommandPackage_Class.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="examples">Examples&lt;/h2>
&lt;p>Detailed use case examples can be seen here:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/pc" target="_blank" rel="noopener">PC&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/android" target="_blank" rel="noopener">Android&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Create a plugin</title><link>https://keyple.org/docs/developer-guide/create-plugin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/create-plugin/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>In order to provide an easy way to port a Keyple application from a device with a specific card reader to another, a plugin system
as been developed. When a developer wants to include Keyple features within his project, he has to initialize the SmartCardService by providing a
plugin Factory available with in the plugin library. The plugin to use depends on the targeted device and running environment.&lt;/p>
&lt;p>For example, for an android device with native NFC we&amp;rsquo;ll use KeypleAndroidNfcPlugin.&lt;/p>
&lt;pre>&lt;code class="language-gradle">implementation 'org.eclipse.keyple:keyple-android-plugin-nfc:$keyple_version'
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
SmartCardService.getInstance().registerPlugin(AndroidNfcPluginFactory())
&lt;/code>&lt;/pre>
&lt;p>Keyple is already provided with various plug-ins ready to use. For example Android NFC or PC/SC reader plugins.&lt;/p>
&lt;p>But users of the Keyple API may need to use it on new hardware not covered with existing plugins. In this case, a new
one must be developed.&lt;/p>
&lt;p>The purpose of this guide is to support developers in this process.&lt;/p>
&lt;h2 id="existing-plugins">Existing plugins&lt;/h2>
&lt;p>The list of reader plugins is maintained on this pages:&lt;/p>
&lt;p>
&lt;a href="https://keyple.org/components-java/plugins/">Java Reader Plugins&lt;/a>&lt;/p>
&lt;p>
&lt;a href="https://keyple.org/components-cpp/plugins/">C++ Reader Plugins&lt;/a>&lt;/p>
&lt;h2 id="class-diagram-of-plugin-package">Class diagram of plugin package&lt;/h2>
&lt;p>For the record, this is a wide view of classes implied in the plugin system. It is designed to natively handle as much
use cas as possible while being easy to use. It results of several internal classes, however, plugin&amp;rsquo;s developers will
only have to use a few part of these elements.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/plugin-development/class/Plugin_Class_Full.svg" >
&lt;img src="../../media/plugin-development/class/Plugin_Class_Full.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h2 id="steps">Steps&lt;/h2>
&lt;p>Plugin&amp;rsquo;s development relies on 3 main steps, each one consists in implementing a few set of abstract classes and interfaces of
plugin package from Keyple Core API:&lt;/p>
&lt;ol>
&lt;li>Import Keyple dependency&lt;/li>
&lt;li>Implement a Keyple Reader&lt;/li>
&lt;li>Implement a Keyple Plugin&lt;/li>
&lt;li>Implement a Keyple Plugin Factory.&lt;/li>
&lt;/ol>
&lt;h2 id="imports">Imports&lt;/h2>
&lt;p>Your plugin will use be based upon Keyple Core library.&lt;/p>
&lt;p>Using the
&lt;a href="https://keyple.org/components-java/core/">Java components&lt;/a> or
&lt;a href="https://keyple.org/components-cpp/core/">C++ components&lt;/a>
pages, import &lt;strong>Keyple Core&lt;/strong> into your project.&lt;/p>
&lt;h2 id="implement-keyple-reader">Implement Keyple Reader&lt;/h2>
&lt;p>The first step of a Keyple plugin development is the implementation of Keyple Reader Interface (org.eclipse.keyple.core.Reader).
This implementation should use device&amp;rsquo;s native smartcard reader library (or sdk package) to map interfaces used by Keyple API.&lt;/p>
&lt;p>This implementation of a local reader must be done through the extension of one of three abstract classes provided within the Keyple API. The choice depends
on expected behaviour of the reader:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>AbstractLocalReader&lt;/code>&lt;/strong>: Basic abstract class to use for local reader implementation.&lt;/li>
&lt;li>&lt;strong>&lt;code>AbstractObservableLocalReader&lt;/code>&lt;/strong>: extends AbstractLocalReader and is used to manage the matter of observing card events in the case of a local reader
(ie: card insertion, card removal..).&lt;/li>
&lt;li>&lt;strong>&lt;code>AbstractObservableLocalAutonomousReader&lt;/code>&lt;/strong>: extends AbstractObservableLocalReader and is used to allow the reader implementation to
call back the core when card insertion and removal events occurs.&lt;/li>
&lt;/ul>
&lt;figure >
&lt;a data-fancybox="" href="../../media/plugin-development/class/AbstractReaders_Class.svg" >
&lt;img src="../../media/plugin-development/class/AbstractReaders_Class.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>Once chosen, the Abstract class must be extended by the new reader class and abstract methods must be implemented. Please refer to your native reader
documentation to implement this elements.&lt;/p>
&lt;h3 id="implementation-of-abstractlocalreaders-abstract-classes">Implementation of AbstractLocalReader&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>Relying on the native smartcard reader of the device, implementations to be done are:&lt;/p>
&lt;div id="plugins-table-1">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to implement&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>boolean checkCardPresence()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Verify the presence of the card&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>byte[] getATR()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>provides the information retrieved when powering up the card&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>openPhysicalChannel()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Attempts to open the physical channel&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>closePhysicalChannel()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Attempts to close the current physical channel&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>boolean isPhysicalChannelOpen()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Tells if the physical channel is open or not&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>boolean isCurrentProtocol(String readerProtocolName)&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Tells if the current card communicates with the protocol provided as an argument&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>byte[] transmitApdu(byte[] apduIn)&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Transmits a single APDU and receives its response. Both are in the form of an array of bytes.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>activateReaderProtocol(String readerProtocolName)&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Activates the protocol provided from the reader&amp;rsquo;s implementation point of view.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>deactivateReaderProtocol(String readerProtocolName)&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Deactivates the protocol provided from the reader&amp;rsquo;s implementation point of view.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>isContactless()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Tells if the current card communication is contactless.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-1 table th:first-of-type {
width: 450px;
}
&lt;/style>
&lt;p>Example of implementations are provided
&lt;a href="#abstractlocalreader">here&lt;/a>.&lt;/p>
&lt;h3 id="implementation-of-abstractobservablelocalreaders-abstract-classes">Implementation of AbstractObservableLocalReader&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>In addition of AbstractLocalReader&amp;rsquo;s methods, specific implementations to be done are:&lt;/p>
&lt;h4 id="methods">Methods&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to implement&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>void onStartDetection()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Invoked when the card detection is started by the Keyple Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>void onStopDetection()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Invoked when the card detection is stopped by the Keyple Plugin&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>ReaderObservationExceptionHandler getObservationExceptionHandler()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Allows to invoke the defined handler when an exception condition needs to be transmitted to the application level&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Beside the implementation of this methods, this observable reader&amp;rsquo;s notification behaviour must be set.&lt;/p>
&lt;h4 id="observable-readers-notification">Observable reader&amp;rsquo;s notification&lt;/h4>
&lt;p>Observable reader&amp;rsquo;s notification behaviour is set up by implementing interfaces inheriting from ObservableReaderNotifiers.
Developer has to choose how the reader should behave regarding its native abilities. It may involve a few more methods to implement.&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="../../media/plugin-development/class/ObservableReaderNotifiers_Interfaces.svg" >
&lt;img src="../../media/plugin-development/class/ObservableReaderNotifiers_Interfaces.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;p>It is &lt;strong>mandatory&lt;/strong> to implement one, and only one, interface of each use case presented in the related columns in the below
table.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Card Insertion&lt;/th>
&lt;th style="text-align:center">Card Removal&lt;/th>
&lt;th style="text-align:center">Card Processing&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>WaitForCardInsertionAutonomous&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>WaitForCardRemovalAutonomous&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>WaitForCardRemovalDuringProcessing&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>WaitForCardInsertionBlocking&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>WaitForCardRemovalBlocking&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>DontWaitForCardRemovalDuringProcessing&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>WaitForCardInsertionNonBlocking&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>WaitForCardRemovalNonBlocking&lt;/code>&lt;/td>
&lt;td style="text-align:center">&amp;mdash;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Description of the Insertion/Removal behaviours:&lt;/p>
&lt;div id="plugins-table-2">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>[*]Autonomous&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Interface to be implemented by readers that have a fully integrated management of card communications for card insertion/removal detection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>[*]Blocking&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Interface to be implemented by readers that are autonomous in the management of waiting for the insertion/removal of a card and that provide a method to wait for it indefinitely.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>[*]Non Blocking&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Interface to be implemented by readers that require an active process to detect the card insertion /removal.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-2 table th:first-of-type {
width: 180px;
}
&lt;/style>
&lt;p>Description of the processing behaviours:&lt;/p>
&lt;div id="plugins-table-3">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>WaitForCardRemovalDuringProcessing&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Interface to be implemented by readers &lt;strong>able&lt;/strong> to detect a card &lt;strong>removal&lt;/strong> during processing, between two APDU commands.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>DontWaitForCardRemovalDuringProcessing&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Interface to be implemented by readers &lt;strong>not able&lt;/strong> to detect a card &lt;strong>removal&lt;/strong> during processing, between two APDU commands.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-3 table th:first-of-type {
width: 350px;
}
&lt;/style>
&lt;p>Example of implementations are provided
&lt;a href="#abstractobservablelocalreader">here&lt;/a>.&lt;/p>
&lt;h3 id="implementation-of-abstractobservablelocalautonomousreaders-abstract-classes">Implementation of AbstractObservableLocalAutonomousReader&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>In addition of AbstractObservableLocalReader&amp;rsquo;s methods and ObservableReaderNotifiers implementation, specific methods invocation must be done:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to invoke&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>void onCardInserted()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>This method must be invoked when a card is inserted to.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>void onCardRemoved()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>This method must be invoked when a card is removed.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Example of implementations are provided
&lt;a href="#abstractobservablelocalautonomousreader">here&lt;/a>.&lt;/p>
&lt;h2 id="implement-keyple-plugin">Implement Keyple Plugin&lt;/h2>
&lt;p>The next step of Keyple plugin development is the implementation of Keyple Plugin Interface (org.eclipse.keyple.core.service.Plugin).
The plugin will provide access to the readers and handle their lifecycle.&lt;/p>
&lt;p>As well as Reader&amp;rsquo;s implementation, abstract classes to extend and interfaces to implement will depend on native abilities of the device.&lt;/p>
&lt;p>This implementation of a plugin must be done through the extension of one of three abstract classes provided within the Keyple API.
The choice depends on expected behaviour of the plugin:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>AbstractPlugin&lt;/code>&lt;/strong>: Basic class for plugin implementation.&lt;/li>
&lt;li>&lt;strong>&lt;code>AbstractObservablePlugin&lt;/code>&lt;/strong>: This class provides the means to observe a plugin(insertion/removal of readers).&lt;/li>
&lt;li>&lt;strong>&lt;code>AbstractThreadedObservablePlugin&lt;/code>&lt;/strong>: This class provides the means to observe a plugin(insertion/removal of readers) using a monitoring thread.&lt;/li>
&lt;/ul>
&lt;figure >
&lt;a data-fancybox="" href="../../media/plugin-development/class/AbstractPlugins_Class.svg" >
&lt;img src="../../media/plugin-development/class/AbstractPlugins_Class.svg" alt="" >
&lt;/a>
&lt;/figure>
&lt;h3 id="implementation-of-abstractplugins-abstract-classes">Implementation of AbstractPlugin&amp;rsquo;s abstract classes&lt;/h3>
&lt;h4 id="initnativereaders">initNativeReaders()&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to implement&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>ConcurrentMap&amp;lt;String, Reader&amp;gt; initNativeReaders()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>This method is invoked when registering a plugin. It should be implemented to init readers map.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Example of implementations are provided
&lt;a href="#initnativereaders-1">here&lt;/a>.&lt;/p>
&lt;h3 id="implementation-of-abstractobservableplugins-abstract-classes">Implementation of AbstractObservablePlugin&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>There is no additional methods to implement compared to AbstractPlugin&lt;/p>
&lt;h3 id="implementation-of-abstractthreadedobservableplugins-abstract-classes">Implementation of AbstractThreadedObservablePlugin&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>In addition of AbstractObservablePlugin&amp;rsquo;s methods and ObservableReaderNotifiers implementation, specific methods invocations must be done:&lt;/p>
&lt;div id="plugins-table-4">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to implement&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>SortedSet&amp;lt;String&amp;gt; fetchNativeReadersNames()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>This method Fetch the list of connected native reader (usually from third party library) and returns their names (or id)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>Reader fetchNativeReader(String name)&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Fetch connected native reader (from third party library) by its name returns the current AbstractReader if it is already listed. Creates and returns a new AbstractReader if not.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-4 table th:first-of-type {
width: 300px;
}
&lt;/style>
&lt;p>Example of implementations are provided
&lt;a href="#abstractthreadedobservableplugin">here&lt;/a>.&lt;/p>
&lt;h3 id="implementation-of-abstractpluginfactorys-abstract-classes">Implementation of AbstractPluginFactory&amp;rsquo;s abstract classes&lt;/h3>
&lt;p>The last step is to implement the Plugin factory which is going to be use by Keyple core to handle the plugin.&lt;/p>
&lt;div id="plugins-table-5">
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Method to implement&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>&lt;code>String getPluginName()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Retrieve the name of the plugin that will be instantiated by this factory (can be static or dynamic)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>&lt;code>Plugin getPlugin()&lt;/code>&lt;/strong>&lt;/td>
&lt;td>Retrieve an instance of a plugin (can be a singleton)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/div>
&lt;style>
#plugins-table-5 table th:first-of-type {
width: 220px;
}
&lt;/style>
&lt;p>Example of implementations are provided
&lt;a href="#abstractthreadedobservableplugin">here&lt;/a>.&lt;/p>
&lt;h2 id="examples-of-implementation">Examples of implementation&lt;/h2>
&lt;h3 id="abstractlocalreader">AbstractLocalReader&lt;/h3>
&lt;h4 id="checkcardpresence">checkCardPresence()&lt;/h4>
&lt;p>Allow Keyple to check if the smartcard is present within the reader (inserted, in NFC field&amp;hellip;)&lt;/p>
&lt;p>OMAPI Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
//nativeReader is an instance of android.se.omapi.Reader. It natively provides a method to check Card presence.
override fun checkCardPresence(): Boolean {
return nativeReader.isSecureElementPresent
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
//When a SE is presented in the NFC field, we can get a tagproxy object. When the SE is removed,
//this value is reinited. So when it is not null, we can assume the SE is currently in the field.
//The presence information is not directly available be we can find a way to implement checkCardPresence()
public override fun checkCardPresence(): Boolean {
return tagProxy != null
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public override fun checkCardPresence(): Boolean {
//Terminal is an instance of CardTerminal provided by javax.smartcardio
return terminal.isCardPresent();
}
&lt;/code>&lt;/pre>
&lt;h4 id="getatr">getAtr()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun getATR(): ByteArray? {
//Session is a native object of android.se.omapi package
return session?.let {
it.atr
}
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
public override fun getATR(): ByteArray? {
//TagProxy is an object mapping android.nfc.tech.TagTechnology. Atr is obtained from data of this object (depending of protocol)
val atr = tagProxy?.atr
return if (atr?.isNotEmpty() == true) atr else null
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public override fun checkCardPresence(): Boolean {
//Card is an instance of card provided by javax.smartcardio
return return card.getATR().getBytes();;
}
&lt;/code>&lt;/pre>
&lt;h4 id="openphysicalchannel">openPhysicalChannel()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
@Throws(KeypleReaderIOException::class)
override fun openPhysicalChannel() {
try {
//nativeReader is an instance of import android.se.omapi.Reader
session = nativeReader.openSession()
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;IOException while opening physical channel.&amp;quot;, e)
}
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
@Throws(KeypleReaderIOException::class)
public override fun openPhysicalChannel() {
//TagProxy is a wrapper we created in the plugin
//To handle android.nfc.Tag
if (tagProxy?.isConnected != true) {
try {
tagProxy?.connect()
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;Error while opening physical channel&amp;quot;, e)
}
}
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public void openPhysicalChannel() {
//card is an instance of Card provided by javax.smartcardio
if (card == null) {
this.card = this.terminal.connect(parameterCardProtocol);
} else {
logger.debug(&amp;quot;[{}] Opening of a card physical channel in shared mode.&amp;quot;, this.getName());
}
}
//CardChannel is an instance of card provided by javax.smartcardio
this.channel = card.getBasicChannel();
}
&lt;/code>&lt;/pre>
&lt;h4 id="closephysicalchannel">closePhysicalChannel()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun closePhysicalChannel() {
//openChannel is an instance of android.se.omapi.Channel
openChannel?.let {
it.session.close()
openChannel = null
}
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
@Throws(KeypleReaderIOException::class)
public override fun closePhysicalChannel() {
try {
//TagProxy is a wrapper we created in the plugin
//To handle android.nfc.Tag
tagProxy?.close()
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;Error while closing physical channel&amp;quot;, e)
} finally {
tagProxy = null
}
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected void closePhysicalChannel() {
try {
//card is an instance of Card provided by javax.smartcardio
if (card != null) {
channel = null;
card.disconnect(true);
card = null;
}
} catch (CardException e) {
throw new KeypleReaderIOException(&amp;quot;Error while closing physical channel&amp;quot;, e);
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="isphysicalchannelopen">isPhysicalChannelOpen()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun isPhysicalChannelOpen(): Boolean {
//Session is an instance of android.se.omapi.Session
return session?.isClosed == false
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
public override fun isPhysicalChannelOpen(): Boolean {
//TagProxy is a wrapper we created in the plugin
//To handle android.nfc.Tag
return tagProxy?.isConnected == true
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected boolean isPhysicalChannelOpen() {
return card != null;
}
&lt;/code>&lt;/pre>
&lt;h4 id="transmitapdubyte-apduin">transmitApdu(byte[] apduIn)&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun transmitApdu(apduIn: ByteArray): ByteArray {
// Initialization
Timber.d(&amp;quot;Data Length to be sent to tag : &amp;quot; + apduIn.size)
Timber.d(&amp;quot;Data in : &amp;quot; + ByteArrayUtil.toHex(apduIn))
var dataOut = byteArrayOf(0)
try {
openChannel.let {
dataOut = it?.transmit(apduIn) ?: throw IOException(&amp;quot;Channel is not open&amp;quot;)
}
} catch (e: IOException) {
throw KeypleReaderIOException(&amp;quot;Error while transmitting APDU&amp;quot;, e)
}
Timber.d(&amp;quot;Data out : &amp;quot; + ByteArrayUtil.toHex(dataOut))
return dataOut
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
public override fun transmitApdu(apduIn: ByteArray): ByteArray {
Timber.d(&amp;quot;Send data to card : ${apduIn.size} bytes&amp;quot;)
return with(tagProxy) {
if (this == null) {
throw KeypleReaderIOException(
&amp;quot;Error while transmitting APDU, invalid out data buffer&amp;quot;)
} else {
try {
val bytes = transceive(apduIn)
if (bytes.size &amp;lt;2) {
throw KeypleReaderIOException(
&amp;quot;Error while transmitting APDU, invalid out data buffer&amp;quot;)
} else {
Timber.d(&amp;quot;Receive data from card : ${ByteArrayUtil.toHex(bytes)}&amp;quot;)
bytes
}
} catch (e: IOException) {
throw KeypleReaderIOException(
&amp;quot;Error while transmitting APDU, invalid out data buffer&amp;quot;, e)
} catch (e: NoSuchElementException) {
throw KeypleReaderIOException(&amp;quot;Error while transmitting APDU, no such Element&amp;quot;, e)
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected byte[] transmitApdu(byte[] apduIn) {
ResponseAPDU apduResponseData;
if (channel != null) {
try {
apduResponseData = channel.transmit(new CommandAPDU(apduIn));
} catch (CardException e) {
throw new KeypleReaderIOException(this.getName() + &amp;quot;:&amp;quot; + e.getMessage());
} catch (IllegalArgumentException e) {
// card could have been removed prematurely
throw new KeypleReaderIOException(this.getName() + &amp;quot;:&amp;quot; + e.getMessage());
}
} else {
// could occur if the card was removed
throw new KeypleReaderIOException(this.getName() + &amp;quot;: null channel.&amp;quot;);
}
return apduResponseData.getBytes();
}
&lt;/code>&lt;/pre>
&lt;h4 id="activatereaderprotocolstring-readerprotocolname">activateReaderProtocol(String readerProtocolName)&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun activateReaderProtocol(readerProtocolName: String?) {
// do nothing as protocol ils not relevant for contact PO
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun activateReaderProtocol(readerProtocolName: String?) {
if (!protocolsMap.containsKey(readerProtocolName)) {
//we map the requested protocol to a custom android protocol
protocolsMap.put(readerProtocolName!!, AndroidNfcProtocolSettings.getSetting(readerProtocolName!!)!!)
}
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected void activateReaderProtocol(String readerProtocolName) {
if (!PcscProtocolSetting.getSettings().containsKey(readerProtocolName)) {
throw new KeypleReaderProtocolNotSupportedException(readerProtocolName);
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="deactivatereaderprotocolstring-readerprotocolname">deactivateReaderProtocol(String readerProtocolName)&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun deactivateReaderProtocol(readerProtocolName: String?) {
// do nothing
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun deactivateReaderProtocol(readerProtocolName: String?) {
if (protocolsMap.containsKey(readerProtocolName)) {
protocolsMap.remove(readerProtocolName)
}
Timber.d(&amp;quot;${getName()}: Deactivate protocol $readerProtocolName.&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected void deactivateReaderProtocol(String readerProtocolName) {
if (!PcscProtocolSetting.getSettings().containsKey(readerProtocolName)) {
throw new KeypleReaderProtocolNotSupportedException(readerProtocolName);
}
if (logger.isDebugEnabled()) {
logger.debug(&amp;quot;{}: Deactivate protocol {}.&amp;quot;, getName(), readerProtocolName);
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="iscurrentprotocolstring-readerprotocolname">isCurrentProtocol(String readerProtocolName)&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun isCurrentProtocol(readerProtocolName: String?): Boolean {
return AndroidOmapiSupportedProtocols.ISO_7816_3.name == readerProtocolName
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun isCurrentProtocol(readerProtocolName: String?): Boolean {
return readerProtocolName == null || protocolsMap.containsKey(readerProtocolName) &amp;amp;&amp;amp; protocolsMap[readerProtocolName] == tagProxy?.tech
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected boolean isCurrentProtocol(String readerProtocolName) {
String protocolRule = PcscProtocolSetting.getSettings().get(readerProtocolName);
String atr = ByteArrayUtil.toHex(card.getATR().getBytes());
return Pattern.compile(protocolRule).matcher(atr).matches();
}
&lt;/code>&lt;/pre>
&lt;h4 id="iscontactless">isContactless()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun isContactless(): Boolean {
//OMAPI is a contact Reader
return false
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun isContactless(): Boolean {
//NFC is a contactless Reader
return true
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public boolean isContactless() {
//isContactless is a custom variable that can be set by the plugin
//as PC/SC can be a contactless or contact reade.
if (isContactless == null) {
/* First time initialisation, the transmission mode has not yet been determined or fixed explicitly, let's ask the plugin to determine it (only once) */
isContactless =
((AbstractPcscPlugin) SmartCardService.getInstance().getPlugin(getPluginName()))
.isContactless(getName());
}
return isContactless;
}
&lt;/code>&lt;/pre>
&lt;h3 id="abstractobservablelocalreader">AbstractObservableLocalReader&lt;/h3>
&lt;h4 id="onstartdetection">onStartDetection()&lt;/h4>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun onStartDetection() {
// When Keyple Core starts detection, we have to use native Android NFC adapter to start nfc scanning
if (contextWeakRef.get() == null) {
throw IllegalStateException(&amp;quot;onStartDetection() failed : no context available&amp;quot;)
}
if (nfcAdapter == null) {
nfcAdapter = NfcAdapter.getDefaultAdapter(contextWeakRef.get()!!)
}
val flags = flags
val options = options
nfcAdapter?.enableReaderMode(contextWeakRef.get(), this, flags, options)
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected void onStartDetection() {
//TODO: completion
}
&lt;/code>&lt;/pre>
&lt;h4 id="onstopdetection">onStopDetection()&lt;/h4>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun onStopDetection() {
//When keyple core stop detection, we invoke native adapter stop NFC scanning
nfcAdapter?.let {
if (contextWeakRef.get() != null) {
it.disableReaderMode(contextWeakRef.get())
} else {
throw IllegalStateException(&amp;quot;onStopDetection failed : no context available&amp;quot;)
}
}
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected void onStopDetection() {
//TODO: completion
}
&lt;/code>&lt;/pre>
&lt;h3 id="observablereadernotifiers">ObservableReaderNotifiers&lt;/h3>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
//Note simplified view of Android NFc implementation
class AndroidNfcReader(activity: Activity) :
//In android NFC, we want an easy way to callback Keyple Core when a card is inserted
//because this event occurs through the native layer.
AbstractObservableLocalAutonomousReader(
AndroidNfcReader.PLUGIN_NAME,
AndroidNfcReader.READER_NAME
),
//Our reader have an integrated management of card insertion detection
WaitForCardInsertionAutonomous,
//Our reader do not have an integrated management of card removal detection
//but we can use it when the card is no longer in the field and trigger a removal event
WaitForCardRemovalBlocking,
//We do not want to catch card removal between exchanges with it
DontWaitForCardRemovalDuringProcessing{}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
//We want to observe card events like insertion, removal...
class AbstractPcscReader extends bstractObservableLocalReader implements PcscReader,
//Our native reader do not have an integrated management of card insertion detection
//but we can use it when the card is in the field and trigger an insertion event
WaitForCardInsertionBlocking,
//We want to detect when card is removed while exchanging data with our reader
WaitForCardRemovalDuringProcessing,
//Our native reader do not have an integrated management of card removal detection
//but we can use it when the card is no longer in the field and trigger a removal event
WaitForCardRemovalBlocking {}
&lt;/code>&lt;/pre>
&lt;h3 id="abstractobservablelocalautonomousreader">AbstractObservableLocalAutonomousReader&lt;/h3>
&lt;h4 id="oncardinserted">onCardInserted()&lt;/h4>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
//Note simplified view of Android NFc implementation
override fun onTagDiscovered(tag: Tag?) {
tag?.let {
try {
tagProxy = TagProxy.getTagProxy(tag)
//onTagDiscovered is triggered natively
//we use below code to forward the information to Keyple core
onCardInserted()
} catch (e: KeypleReaderException) {
Timber.e(e)
}
}
}
&lt;/code>&lt;/pre>
&lt;h4 id="oncardremoved">onCardRemoved()&lt;/h4>
&lt;h3 id="abstractplugin">AbstractPlugin&lt;/h3>
&lt;h4 id="initnativereaders-1">initNativeReaders()&lt;/h4>
&lt;p>OMAPI Exemple&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun initNativeReaders(): ConcurrentSkipListMap&amp;lt;String, Reader&amp;gt; {
val readers = ConcurrentSkipListMap&amp;lt;String, Reader&amp;gt;()
//seService is an instance of android.se.omapi.SEService
seService?.readers.forEach { nativeReader -&amp;gt;
//mapToReader creates an instance of our Keyple reader from a native reader
val reader = mapToReader(nativeReader)
readers[reader.name] = reader
}
return readers
}
&lt;/code>&lt;/pre>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun initNativeReaders(): ConcurrentMap&amp;lt;String, Reader&amp;gt;? {
val readers = ConcurrentHashMap&amp;lt;String, Reader&amp;gt;()
//AndroidNfcReaderImpl is our implementation of Keyple reader
readers[AndroidNfcReader.READER_NAME] = AndroidNfcReaderImpl(activity, readerObservationExceptionHandler)
return readers
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected Map&amp;lt;String, Reader&amp;gt; initNativeReaders() {
ConcurrentMap&amp;lt;String, Reader&amp;gt; nativeReaders = new ConcurrentHashMap&amp;lt;String, Reader&amp;gt;();
//CardTerminal is a a class from javax.smartcardio
CardTerminals terminals = getCardTerminals();
try {
for (CardTerminal terminal : terminals.list()) {
final PcscReader pcscReader = createReader(this.getName(), terminal);
nativeReaders.put(pcscReader.getName(), pcscReader);
}
} catch (CardException e) {
}
return nativeReaders;
}
&lt;/code>&lt;/pre>
&lt;h3 id="abstractthreadedobservableplugin">AbstractThreadedObservablePlugin&lt;/h3>
&lt;h4 id="fetchnativereadersnames">fetchNativeReadersNames()&lt;/h4>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
public SortedSet&amp;lt;String&amp;gt; fetchNativeReadersNames() {
SortedSet&amp;lt;String&amp;gt; nativeReadersNames = new ConcurrentSkipListSet&amp;lt;String&amp;gt;();
CardTerminals terminals = getCardTerminals();
try {
for (CardTerminal terminal : terminals.list()) {
nativeReadersNames.add(terminal.getName());
}
} catch (CardException e) {
}
return nativeReadersNames;
}
&lt;/code>&lt;/pre>
&lt;h4 id="fetchnativereader">fetchNativeReader()&lt;/h4>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
protected Reader fetchNativeReader(String name) {
// return the current reader if it is already listed
Reader reader = readers.get(name);
if (reader != null) {
return reader;
}
/* parse the current PC/SC readers list to create the ProxyReader(s) associated with new reader(s) */
CardTerminals terminals = getCardTerminals();
try {
for (CardTerminal terminal : terminals.list()) {
if (terminal.getName().equals(name)) {
reader = createReader(this.getName(), terminal);
}
}
} catch (CardException e) {
throw new KeypleReaderIOException(&amp;quot;Could not access terminals list&amp;quot;, e);
}
if (reader == null) {
throw new KeypleReaderNotFoundException(&amp;quot;Reader &amp;quot; + name + &amp;quot; not found!&amp;quot;);
}
return reader;
}
&lt;/code>&lt;/pre>
&lt;h3 id="pluginfactory">PluginFactory&lt;/h3>
&lt;h4 id="getpluginname">getPluginName()&lt;/h4>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun getPluginName(): String {
return AndroidNfcPlugin.PLUGIN_NAME
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public String getPluginName() {
return PLUGIN_NAME;
}
&lt;/code>&lt;/pre>
&lt;h4 id="getplugin">getPlugin()&lt;/h4>
&lt;p>Android NFC Example&lt;/p>
&lt;pre>&lt;code class="language-kotlin">[kotlin]
override fun getPlugin(): Plugin {
return AndroidNfcPluginImpl(activity, readerObservationExceptionHandler)
}
&lt;/code>&lt;/pre>
&lt;p>PC/SC Example&lt;/p>
&lt;pre>&lt;code class="language-java">[java]
public PcscPlugin getPlugin() {
try {
if (isOsWin) {
return PcscPluginWinImpl.getInstance();
} else {
return PcscPluginImpl.getInstance();
}
} catch (Exception e) {
throw new KeyplePluginInstantiationException(&amp;quot;Can not access smartcard.io readers&amp;quot;, e);
}
}
&lt;/code>&lt;/pre>
&lt;h2 id="sources">Sources&lt;/h2>
&lt;h3 id="keyple-android-nfc">Keyple Android NFC&lt;/h3>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/android/keyple-plugin/android-nfc" target="_blank" rel="noopener">Plugin&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/android/nfc" target="_blank" rel="noopener">Example App&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="keyple-android-omapi">Keyple Android OMAPI&lt;/h4>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/android/keyple-plugin/android-omapi" target="_blank" rel="noopener">Plugin&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/android/omapi" target="_blank" rel="noopener">Example App&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="pcsc">PC/SC&lt;/h4>
&lt;ul>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/component/keyple-plugin/pcsc" target="_blank" rel="noopener">Plugin&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://github.com/eclipse/keyple-java/tree/master/java/example/calypso/pc" target="_blank" rel="noopener">Example Apps&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Create an extension</title><link>https://keyple.org/docs/developer-guide/create-extension/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/create-extension/</guid><description>&lt;div class="alert alert-note">
&lt;div>
Coming soon
&lt;/div>
&lt;/div></description></item><item><title>Migration Guide - Keyple Java 0.8.1 to 0.9.0</title><link>https://keyple.org/docs/developer-guide/migration-0.8.1-to-0.9.0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://keyple.org/docs/developer-guide/migration-0.8.1-to-0.9.0/</guid><description>&lt;p>This guide is intended to help a user of version 0.8.1 of Keyple Java to upgrade his application to the 0.9.0 version of the library.&lt;/p>
&lt;p>From a user API point of view, the changes relate to the following topics:&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="#plugin-registration-in-the-seproxyservice">plugin registration in the SeProxyService&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#preparation-of-selection-cases">preparation of selection cases&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#retrieving-selection-results">retrieving selection results&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#definition-of-the-security-settings-of-the-transaction">definition of the security settings of the transaction&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#creation-of-the-potransaction-object">creation of the PoTransaction object&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#transaction-commands-preparation">transaction commands preparation&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#transaction-commands-processing">transaction commands processing&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#retrieving-data-read-from-pos">retrieving data read from POs&lt;/a>&lt;/li>
&lt;li>
&lt;a href="#error-handling">error handling&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="plugin-registration-in-the-seproxyservice">Plugin registration in the SeProxyService&lt;/h2>
&lt;p>The &lt;code>registerPlugin&lt;/code> method of the &lt;code>SeProxyService&lt;/code> class now returns the reference of the registered plugin.&lt;/p>
&lt;p>This makes it possible, for example, to perform a reader setup in an application such as this one:&lt;/p>
&lt;pre>&lt;code class="language-java"> // Create a PcscPlugin and register it into the SeProxyService
ReaderPlugin pcscPlugin = seProxyService.registerPlugin(new PcscPluginFactory());`
// Get the PO reader from the plugin
SeReader poReader = pcscPlugin.getReader(&amp;quot;ASK LoGO 0&amp;quot;);
&lt;/code>&lt;/pre>
&lt;h2 id="preparation-of-selection-cases">Preparation of selection cases&lt;/h2>
&lt;p>The &lt;code>AidSelector&lt;/code>, &lt;code>Selector&lt;/code> and &lt;code>PoSelector&lt;/code> classes now follow the Fluent Builder pattern for better handling of optional parameters.&lt;/p>
&lt;p>The construction of an &lt;code>AidSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector appAidSelector = AidSelector.builder()
.aidToSelect(AID)
.fileControlInformation(AidSelector.FileControlInformation.FCI)
.fileOccurrence(AidSelector.FileOccurrence.FIRST)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>fileControlInformation&lt;/code> and &lt;code>fileOccurrence&lt;/code> fields are optional (shown here with their default values), so a simple version can be :&lt;/p>
&lt;pre>&lt;code class="language-java">AidSelector aidSelector = AidSelector.builder().aidToSelect(CalypsoClassicInfo.AID).build();
&lt;/code>&lt;/pre>
&lt;p>The construction of a &lt;code>SeSelector&lt;/code> is as follows:&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.build();
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>PoSelector&lt;/code> adds the possibility to specify that an invalidated PO should be processed&lt;/p>
&lt;pre>&lt;code class="language-java">seSelector = SeSelector.builder()
.seProtocol(SeCommonProtocols.PROTOCOL_ISO14443_4)
.aidSelector(appAidSelector)
.invalidatedPo(InvalidatedPo.ACCEPT)
.build();
&lt;/code>&lt;/pre>
&lt;p>The management of PO commands to be performed after the selection step (when it has been successful) is handled by the methods of the &lt;code>PoSelectionRequest&lt;/code> class:&lt;/p>
&lt;ul>
&lt;li>preparing to read files has been simplified and is done using the unique following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareReadRecordFile(byte sfi, int recordNumber)
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>preparing to select files is done using the following method:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-java">public void prepareSelectFile(byte[] lid)
public void prepareSelectFile(short lid)
&lt;/code>&lt;/pre>
&lt;p>Note that from now the &amp;ldquo;prepare&amp;rdquo; methods no longer return indexes, the data will be placed in the CalypsoPo object.&lt;/p>
&lt;h2 id="retrieving-selection-results">Retrieving selection results&lt;/h2>
&lt;p>The &lt;code>MatchingSelection&lt;/code> class no longer exists.
In the class &lt;code>SelectionsResult&lt;/code> (see &lt;code>processDefaultSelection/processExplicitSelection&lt;/code>):&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>getActiveSelection&lt;/code> is replaced by &lt;code>getActiveMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelection&lt;/code> is replaced by &lt;code>getMatchingSe&lt;/code> which returns an &lt;code>AbstractMatchingSe&lt;/code> object (may be null if the index provided does not correspond to a successful selection case)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>getMatchingSelections&lt;/code> now returns a Map containing a list of associated &lt;code>AbstractMatchingSe&lt;/code> with the selection index that produced it (&lt;code>Map&amp;lt;Integer, AbstractMatchingSe&amp;gt;&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>hasSelectionMatched&lt;/code> method indicates whether the selection index provided corresponds to a successful selection case&lt;/p>
&lt;/li>
&lt;li>
&lt;p>a new &lt;code>getActiveSelectionIndex&lt;/code> method returns the index of the active selection (the still existing &lt;code>hasActiveSelection&lt;/code> method must be used before)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="definition-of-the-security-settings-of-the-transaction">Definition of the security settings of the transaction&lt;/h2>
&lt;p>These parameters are defined via the &lt;code>PoSecuritySettings&lt;/code> class, whose construction now follows the Fluent Builder pattern.&lt;/p>
&lt;p>All parameters are optional except the &lt;code>SamResource&lt;/code>.&lt;/p>
&lt;p>Here is an example of a complete &lt;code>PoSecuritySettings&lt;/code> build:&lt;/p>
&lt;pre>&lt;code class="language-java">poSecuritySettings = new PoSecuritySettings.PoSecuritySettingsBuilder(samResource)
.sessionDefaultKif(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KIF_PERSO)
.sessionDefaultKif(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KIF_LOAD)
.sessionDefaultKif(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KIF_DEBIT)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_PERSO, DEFAULT_KEY_RECORD_NUMBER_PERSO)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_LOAD, DEFAULT_KEY_RECORD_NUMBER_LOAD)
.sessionDefaultKeyRecordNumber(AccessLevel.SESSION_LVL_DEBIT, DEFAULT_KEY_RECORD_NUMBER_DEBIT)
.sessionModificationMode(ModificationMode.ATOMIC)
.ratificationMode(RatificationMode.CLOSE_RATIFIED)
.sessionAuthorizedKvcList(authKvcs)
.build();
&lt;/code>&lt;/pre>
&lt;h2 id="creation-of-the-potransaction-object">Creation of the PoTransaction object&lt;/h2>
&lt;p>Since PoSecuritySettings now integrates SamResource, the construction of PoTransaction has evolved slightly.&lt;/p>
&lt;p>Here is an example:&lt;/p>
&lt;pre>&lt;code class="language-java">PoTransaction poTransaction = new PoTransaction(new PoResource(poReader, calypsoPo), poSecuritySettings);
&lt;/code>&lt;/pre>
&lt;h2 id="transaction-commands-preparation">Transaction commands preparation&lt;/h2>
&lt;p>Just as with the &amp;ldquo;prepare&amp;rdquo; commands used for selection, the &amp;ldquo;prepare&amp;rdquo; commands used for transactions no longer return indexes.&lt;/p>
&lt;p>The available commands in version 0.9 are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final void prepareSelectFile(SelectFileControl control)
public final void prepareSelectFile(short lid)
public final void prepareSelectFile(byte[] lid)
public final void prepareReadRecordFile(byte sfi, int recordNumber)
public final void prepareReadRecordFile(byte sfi, int firstRecordNumber, int numberOfRecords, int recordSize))
public final void prepareReadCounterFile(byte sfi, int countersNumber)
public final void prepareUpdateRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareWriteRecord(byte sfi, int recordNumber, byte[] recordData)
public final void prepareAppendRecord(byte sfi, byte[] recordData)
public final void prepareIncreaseCounter(byte sfi, int counterNumber, int incValue)
public final void prepareDecreaseCounter(byte sfi, int counterNumber, int decValue)
&lt;/code>&lt;/pre>
&lt;h2 id="transaction-commands-processing">Transaction commands processing&lt;/h2>
&lt;p>The &amp;ldquo;process&amp;rdquo; commands have also been revised and simplified.&lt;/p>
&lt;p>They all return &lt;code>void&lt;/code>.&lt;/p>
&lt;p>In case of failure a exception is raised (see below).&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processOpening(PoTransaction.SessionSetting.AccessLevel accessLevel)
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>ModificationMode&lt;/code> is no longer required since it is integrated in the &lt;code>PoSecuritySettings&lt;/code>.&lt;/p>
&lt;p>Parameters previously used to specify that a file is read at login are removed.&lt;/p>
&lt;p>Instead, the first prepareReadFile command will be automatically taken into account.&lt;/p>
&lt;pre>&lt;code class="language-java">public final void processPoCommands()
public final void processPoCommandsInSession()
public final void processCancel(ChannelControl channelControl)
public final void processClosing(ChannelControl channelControl)
&lt;/code>&lt;/pre>
&lt;h2 id="retrieving-data-read-from-pos">Retrieving data read from POs&lt;/h2>
&lt;p>This is a major evolution of the Keyple API. Previously, data read from Calyspo POs were retrieved by applications using &amp;ldquo;parser&amp;rdquo; methods.&lt;/p>
&lt;p>With Keyple API 0.9, Calypso PO data is made available in the CalypsoPo object obtained during selection and enriched all along the operations performed with PoTransaction.&lt;/p>
&lt;p>The public getter methods of CalypsoPo are:&lt;/p>
&lt;pre>&lt;code class="language-java">public final String getDfName()
public final byte[] getDfNameBytes()
public final String getApplicationSerialNumber()
public final byte[] getApplicationSerialNumberBytes()
public final String getAtr()
public final String getStartupInfo()
public final PoRevision getRevision()
public final byte getSessionModification()
public final byte getApplicationType()
public final byte getApplicationSubtype()
public final byte getPlatform()
public final byte getSoftwareIssuer()
public final byte getSoftwareVersion()
public final byte getSoftwareRevision()
public final boolean isDeselectRatificationSupported()
public final boolean isConfidentialSessionModeSupported()
public final boolean isPublicAuthenticationSupported()
public final boolean isPinFeatureAvailable()
public final boolean isSvFeatureAvailable()
public final boolean isDfInvalidated()
public final boolean isDfRatified()
public final DirectoryHeader getDirectoryHeader()
public final ElementaryFile getFileBySfi(byte sfi)
public final ElementaryFile getFileByLid(short lid)
public final Map&amp;lt;Byte, ElementaryFile&amp;gt; getAllFiles()
&lt;/code>&lt;/pre>
&lt;p>Four new classes &lt;code>DirectoryHeader&lt;/code>, &lt;code>ElementaryFile&lt;/code>, &lt;code>FileHeader&lt;/code> and &lt;code>FileData&lt;/code> have been added.&lt;/p>
&lt;h5 id="directoryheader">DirectoryHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public byte getDfStatus()
public byte getKif(AccessLevel level)
public byte getKvc(AccessLevel level)
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="elementaryfile">ElementaryFile&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte getSfi()
public FileHeader getHeader()
public FileData getData()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="fileheader">FileHeader&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public short getLid()
public int getRecordsNumber()
public int getRecordSize()
public FileType getType()
public byte getDfStatus()
public boolean isShared()
public Short getSharedReference()
public byte[] getAccessConditions()
public byte[] getKeyIndexes()
public String toString()
&lt;/code>&lt;/pre>
&lt;h5 id="filedata">FileData&lt;/h5>
&lt;p>The public getters for this class are:&lt;/p>
&lt;pre>&lt;code class="language-java">public byte[] getContent()
public byte[] getContent(int numRecord)
public byte[] getContent(int numRecord, int dataOffset, int dataLength)
public SortedMap&amp;lt;Integer, byte[]&amp;gt; getAllRecordsContent()
public int getContentAsCounterValue(int numCounter)
public SortedMap&amp;lt;Integer, Integer&amp;gt; getAllCountersValue()
public String toString()
&lt;/code>&lt;/pre>
&lt;p>So, for example to extract the contents of contract files present in the PO, the code might look like this:&lt;/p>
&lt;pre>&lt;code class="language-java">[...]
/* Read all 4 contracts command, record size set to 29 */
poTransaction.prepareReadRecordFile(CalypsoClassicInfo.SFI_Contracts,
CalypsoClassicInfo.RECORD_NUMBER_1, 4, 29);
/* proceed with the sending of commands, don't close the channel */
poTransaction.processPoCommandsInSession();
ElementaryFile efContracts = calypsoPo.getFileBySfi(CalypsoClassicInfo.SFI_Contracts);
SortedMap&amp;lt;Integer, byte[]&amp;gt; records = efContracts.getData().getAllRecordsContent();
for (Map.Entry&amp;lt;Integer, byte[]&amp;gt; entry : records.entrySet()) {
logger.info(&amp;quot;Contract #{}: {}&amp;quot;, entry.getKey(),
ByteArrayUtil.toHex(entry.getValue()));
}
[...]
&lt;/code>&lt;/pre>
&lt;h2 id="error-handling">Error handling&lt;/h2>
&lt;p>Since version 0.9, all Keyple exceptions are of the RuntimeException type.&lt;/p>
&lt;p>Catching exceptions is therefore now optional.&lt;/p>
&lt;p>However, it is possible to selectively catch certain exceptions in order to deal with particular cases.&lt;/p>
&lt;p>The new hierarchy of Keyple exceptions is shown
&lt;a href="https://keyple.atlassian.net/projects/KEYP/issues/KEYP-154?filter=allissues&amp;amp;orderby=priority%20DESC&amp;amp;keyword=exceptions" target="_blank" rel="noopener">here&lt;/a>&lt;/p></description></item></channel></rss>